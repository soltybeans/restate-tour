/// <reference types="node" />
import * as p from "./types/protocol";
import { Connection, RestateStreamConsumer } from "./connection/connection";
import { Message } from "./types/types";
import { StateMachineConsole } from "./utils/message_logger";
import { Invocation } from "./invocation";
import { JournalErrorContext } from "./types/errors";
import { LocalStateStore } from "./local_state_store";
import { LoggerContext } from "./logger";
import { WrappedPromise } from "./utils/promises";
import { PromiseId } from "./promise_combinator_tracker";
import { ProtocolMode } from "./types/discovery";
import { Buffer } from "node:buffer";
import { HandlerKind } from "./types/rpc";
export declare class StateMachine implements RestateStreamConsumer {
    private readonly connection;
    private readonly invocation;
    private readonly protocolMode;
    private readonly suspensionMillis;
    private journal;
    private restateContext;
    private readonly invocationComplete;
    private stateMachineClosed;
    readonly localStateStore: LocalStateStore;
    private inputChannelClosed;
    private suspensionTimeout?;
    private promiseCombinatorTracker;
    console: StateMachineConsole;
    constructor(connection: Connection, invocation: Invocation, protocolMode: ProtocolMode, handlerKind: HandlerKind, loggerContext: LoggerContext, suspensionMillis?: number);
    handleMessage(m: Message): boolean;
    handleUserCodeMessage<T>(messageType: bigint, message: p.ProtocolMessage, completedFlag?: boolean, requiresAckFlag?: boolean): WrappedPromise<T | void>;
    createCombinator(combinatorConstructor: (promises: PromiseLike<unknown>[]) => Promise<unknown>, promises: Array<{
        id: PromiseId;
        promise: Promise<unknown>;
    }>): WrappedPromise<unknown>;
    readCombinatorOrderEntry(combinatorId: number): PromiseId[] | undefined;
    writeCombinatorOrderEntry(combinatorId: number, order: PromiseId[]): Promise<void>;
    /**
     * Invokes the RPC function and returns a promise that completes when the state machine
     * stops processing the invocation, meaning when:
     *   - The function completes with a result or an exception
     *   - The execution suspends
     *   - An error is raised in the state machine (network, API violation, ...)
     *
     * The returned promise resolves successfully for all the cases above, because the are (from
     * the perspective of the state machine) expected outcomes in which it send out corresponding
     * result messages and cleanly closed the connection.
     *
     * The returned promise is rejected when an unhandled error arises and the caller would be
     * expected to ensure that resources are properly cleaned up.
     */
    invoke(): Promise<Buffer | void>;
    sendErrorAndFinish(e: Error, ctx?: JournalErrorContext): Promise<void>;
    private sendRetryableError;
    private sendTerminalError;
    private send;
    /**
     * Closes the state machine, flushes all output, and resolves the invocation promise.
     */
    private finish;
    /**
     * This function propagates errors up to the completion promise, to be handled
     * on the connection layer.
     */
    private unhandledError;
    /**
     * This method is invoked when we hit a suspension point. A suspension point is everytime the user "await"s a Promise returned by RestateContext that might be completed at a later point in time by a CompletionMessage/AckMessage.
     *
     * Depending on the state of the read channel, and on the protocol mode, it might either immediately suspend, or schedule a suspension to happen at a later point in time.
     */
    private hitSuspensionPoint;
    private getSuspensionMillis;
    private suspend;
    /**
     * WARNING: make sure you use this at the right point in the code
     * After the index has been incremented...
     * This is error-prone... Would be good to have a better solution for this.
     */
    getUserCodeJournalIndex(): number;
    handleInputClosed(): void;
    handleStreamError(e: Error): void;
    handleDanglingPromiseError(e: Error): void;
    nextEntryWillBeReplayed(): boolean;
    private clearSuspensionTimeout;
}
//# sourceMappingURL=state_machine.d.ts.map