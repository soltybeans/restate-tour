import * as p from "./types/protocol";
import { Failure } from "./generated/proto/protocol_pb";
import { CompletionMessage, EntryAckMessage, OutputEntryMessage, SuspensionMessage } from "./types/protocol";
import { Message } from "./types/types";
import { Invocation } from "./invocation";
import { CompletablePromise } from "./utils/promises";
export declare class Journal {
    readonly invocation: Invocation;
    private state;
    private userCodeJournalIndex;
    private pendingJournalEntries;
    constructor(invocation: Invocation);
    handleInputMessage(m: p.InputEntryMessage): void;
    handleUserSideMessage(messageType: bigint, message: p.ProtocolMessage | Uint8Array): Promise<any | undefined>;
    isUnResolved(index: number): boolean;
    handleRuntimeCompletionMessage(m: CompletionMessage): void;
    handleEntryAckMessage(m: EntryAckMessage): void;
    private handleReplay;
    resolveResult<T>(journalIndex: number, journalEntry: JournalEntry, value: T | undefined, failure?: Failure | undefined, failureWouldBeTerminal?: boolean): void;
    handleClosingMessage(messageType: bigint, message: OutputEntryMessage | SuspensionMessage): void;
    private checkJournalMatch;
    getCompletableIndices(): number[];
    private transitionState;
    incrementUserCodeIndex(): void;
    /**
     * Read the next replay entry
     */
    readNextReplayEntry(): Message | undefined;
    /**
     * Append journal entry. This won't increment the journal index.
     */
    appendJournalEntry(messageType: bigint, message: p.ProtocolMessage | Uint8Array): Promise<unknown>;
    isClosed(): boolean;
    isProcessing(): boolean;
    isReplaying(): boolean;
    getUserCodeJournalIndex(): number;
    close(): void;
    outputMsgWasReplayed(): boolean | undefined;
    nextEntryWillBeReplayed(): boolean;
}
export declare class JournalEntry {
    readonly messageType: bigint;
    readonly message: p.ProtocolMessage | Uint8Array;
    completablePromise: CompletablePromise<unknown>;
    constructor(messageType: bigint, message: p.ProtocolMessage | Uint8Array);
}
export declare enum NewExecutionState {
    REPLAYING = "REPLAYING",
    PROCESSING = "PROCESSING",
    CLOSED = "CLOSED"
}
//# sourceMappingURL=journal.d.ts.map