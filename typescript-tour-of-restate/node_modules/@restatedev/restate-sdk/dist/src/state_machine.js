"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateMachine = void 0;
const p = __importStar(require("./types/protocol"));
const context_impl_1 = require("./context_impl");
const types_1 = require("./types/types");
const message_logger_1 = require("./utils/message_logger");
const protocol_1 = require("./types/protocol");
const journal_1 = require("./journal");
const errors_1 = require("./types/errors");
const logger_1 = require("./logger");
const promises_1 = require("./utils/promises");
const promise_combinator_tracker_1 = require("./promise_combinator_tracker");
const javascript_pb_1 = require("./generated/proto/javascript_pb");
const discovery_1 = require("./types/discovery");
const node_buffer_1 = require("node:buffer");
class StateMachine {
    connection;
    invocation;
    protocolMode;
    suspensionMillis;
    journal;
    restateContext;
    invocationComplete = new promises_1.CompletablePromise();
    // when this flag is true, no more work will (and may) happen
    // this is set to true in case of
    //  - a completed invocation
    //  - a suspension
    //  - an error in the state machine
    stateMachineClosed = false;
    localStateStore;
    // Whether the input channel (runtime -> service) is closed
    // If it is closed, then we suspend immediately upon the next suspension point
    // If it is open, then we suspend later because we might still get completions
    inputChannelClosed = false;
    // Suspension timeout that gets set and cleared based on completion messages;
    suspensionTimeout;
    promiseCombinatorTracker;
    console;
    constructor(connection, invocation, protocolMode, handlerKind, loggerContext, suspensionMillis = 30_000) {
        this.connection = connection;
        this.invocation = invocation;
        this.protocolMode = protocolMode;
        this.suspensionMillis = suspensionMillis;
        this.localStateStore = invocation.localStateStore;
        this.console = (0, message_logger_1.createStateMachineConsole)(loggerContext);
        this.restateContext = new context_impl_1.ContextImpl(this.invocation.id, 
        // The console exposed by RestateContext filters logs in replay, while the internal one is based on the ENV variables.
        (0, logger_1.createRestateConsole)(loggerContext, () => !this.journal.isReplaying()), handlerKind, invocation.userKey, invocation.invocationValue, invocation.invocationHeaders, connection.headers(), this);
        this.journal = new journal_1.Journal(this.invocation);
        this.promiseCombinatorTracker = new promise_combinator_tracker_1.PromiseCombinatorTracker(this.readCombinatorOrderEntry.bind(this), this.writeCombinatorOrderEntry.bind(this));
    }
    handleMessage(m) {
        if (this.stateMachineClosed) {
            // ignore this message
            return false;
        }
        if (m.messageType === protocol_1.COMPLETION_MESSAGE_TYPE) {
            this.console.debugJournalMessage("Received completion message from Restate, adding to journal.", m.messageType, m.message);
            this.journal.handleRuntimeCompletionMessage(m.message);
        }
        else if (m.messageType === protocol_1.ENTRY_ACK_MESSAGE_TYPE) {
            this.console.debugJournalMessage("Received entry ack message from Restate, adding to journal.", m.messageType, m.message);
            this.journal.handleEntryAckMessage(m.message);
        }
        else {
            throw errors_1.RetryableError.protocolViolation(`Received message of type ${m.messageType}. Can only accept completion or acks messages after replay has finished.`);
        }
        // Remove lingering suspension timeouts, if we are not waiting for completions anymore
        if (this.suspensionTimeout !== undefined &&
            this.journal.getCompletableIndices().length === 0) {
            clearTimeout(this.suspensionTimeout);
            this.suspensionTimeout = undefined;
        }
        return false; // we are never complete
    }
    handleUserCodeMessage(messageType, message, completedFlag, requiresAckFlag) {
        // if the state machine is already closed, return a promise that never
        // completes, so that the user code does not resume
        if (this.stateMachineClosed) {
            return promises_1.WRAPPED_PROMISE_PENDING;
        }
        const promise = this.journal.handleUserSideMessage(messageType, message);
        const journalIndex = this.journal.getUserCodeJournalIndex();
        // Only send the message to restate if we are not in replaying mode
        if (this.journal.isProcessing()) {
            this.console.debugJournalMessage("Adding message to journal and sending to Restate", messageType, message);
            this.send(new types_1.Message(messageType, message, completedFlag, requiresAckFlag));
        }
        else {
            this.console.debugJournalMessage("Matched and replayed message from journal", messageType, message);
        }
        return (0, promises_1.wrapDeeply)(promise, () => {
            if (!p.SUSPENSION_TRIGGERS.includes(messageType)) {
                return;
            }
            if (this.journal.isUnResolved(journalIndex)) {
                this.hitSuspensionPoint();
            }
        });
    }
    // -- Methods related to combinators to wire up promise combinator API with PromiseCombinatorTracker
    createCombinator(combinatorConstructor, promises) {
        if (this.stateMachineClosed) {
            return promises_1.WRAPPED_PROMISE_PENDING;
        }
        // We don't need the promise wrapping here to schedule a suspension,
        // because the combined promises will already have that, so once we call then() on them,
        // if we have to suspend we will suspend.
        return this.promiseCombinatorTracker.createCombinator(combinatorConstructor, promises);
    }
    readCombinatorOrderEntry(combinatorId) {
        const wannabeCombinatorEntry = this.journal.readNextReplayEntry();
        if (wannabeCombinatorEntry === undefined) {
            // We're in processing mode
            return undefined;
        }
        if (wannabeCombinatorEntry.messageType !== protocol_1.COMBINATOR_ENTRY_MESSAGE) {
            throw errors_1.RetryableError.journalMismatch(this.journal.getUserCodeJournalIndex(), wannabeCombinatorEntry, {
                messageType: protocol_1.COMBINATOR_ENTRY_MESSAGE,
                message: {
                    combinatorId,
                },
            });
        }
        const combinatorMessage = wannabeCombinatorEntry.message;
        if (combinatorMessage.combinatorId != combinatorId) {
            throw errors_1.RetryableError.journalMismatch(this.journal.getUserCodeJournalIndex(), wannabeCombinatorEntry, {
                messageType: protocol_1.COMBINATOR_ENTRY_MESSAGE,
                message: {
                    combinatorId,
                },
            });
        }
        this.console.debugJournalMessage("Matched and replayed message from journal", protocol_1.COMBINATOR_ENTRY_MESSAGE, combinatorMessage);
        return combinatorMessage.journalEntriesOrder.map((id) => ({
            id,
            type: promise_combinator_tracker_1.PromiseType.JournalEntry,
        }));
    }
    async writeCombinatorOrderEntry(combinatorId, order) {
        if (this.journal.isProcessing()) {
            const combinatorMessage = new javascript_pb_1.CombinatorEntryMessage({
                combinatorId,
                journalEntriesOrder: order.map((pid) => pid.id),
            });
            this.console.debugJournalMessage("Adding message to journal and sending to Restate", protocol_1.COMBINATOR_ENTRY_MESSAGE, combinatorMessage);
            const ackPromise = this.journal.appendJournalEntry(protocol_1.COMBINATOR_ENTRY_MESSAGE, combinatorMessage);
            this.send(new types_1.Message(protocol_1.COMBINATOR_ENTRY_MESSAGE, combinatorMessage, undefined, true));
            this.hitSuspensionPoint();
            await ackPromise;
        }
    }
    /**
     * Invokes the RPC function and returns a promise that completes when the state machine
     * stops processing the invocation, meaning when:
     *   - The function completes with a result or an exception
     *   - The execution suspends
     *   - An error is raised in the state machine (network, API violation, ...)
     *
     * The returned promise resolves successfully for all the cases above, because the are (from
     * the perspective of the state machine) expected outcomes in which it send out corresponding
     * result messages and cleanly closed the connection.
     *
     * The returned promise is rejected when an unhandled error arises and the caller would be
     * expected to ensure that resources are properly cleaned up.
     */
    invoke() {
        // --------------------------------------------------------------------------------------------
        // Implementation note:
        //
        // This method is not async, because we don't want to actually await anything
        // in there. We cannot await the completion of the actual invocation, because for long-running
        // code (that suspends), the function invocation never completes. Instead, the state machine
        // triggers a suspension.
        // We need to do a bit of promise chaining for the rpc function promise, and return a different
        // promise that completes in also in suspension and error cases.
        // --------------------------------------------------------------------------------------------
        // it is unexpected for the state machine to be closed here, so we raise an error in
        // that case, unlike in other places, where we simply ignore things
        if (this.stateMachineClosed) {
            return Promise.reject(new Error("state machine is already closed"));
        }
        if (this.journal.nextEntryWillBeReplayed()) {
            this.console.info("Resuming (replaying) function.");
        }
        else {
            this.console.info("Invoking function.");
        }
        this.invocation.handler
            .invoke(this.restateContext, this.invocation.invocationValue)
            .then((bytes) => {
            // invocation successfully returned with a result value
            try {
                // the state machine might be closed here in some cases like when there was an error (like
                // API violation) or a suspension, but the function code still completed
                if (this.stateMachineClosed) {
                    this.console.warn("Unexpected successful completion of the function after the state machine closed. " +
                        "This may indicate that: \n" +
                        "- the function code does not properly await some Restate calls " +
                        "and did not notice an error \n" +
                        "- the function code was delayed for longer than the suspension timeout \n" +
                        "- the function code contained a try-catch block around a side effect which throws retryable errors. " +
                        "This try-catch block should be placed inside the side effect.");
                    return;
                }
                const value = node_buffer_1.Buffer.from(bytes);
                // handle the result value
                const msg = new types_1.Message(protocol_1.OUTPUT_ENTRY_MESSAGE_TYPE, new protocol_1.OutputEntryMessage({
                    result: { case: "value", value },
                }));
                this.journal.handleUserSideMessage(msg.messageType, msg.message);
                if (!this.journal.outputMsgWasReplayed()) {
                    this.send(msg);
                    this.console.debugJournalMessage("Journaled and sent output message", msg.messageType, msg.message);
                }
                else {
                    this.console.debugJournalMessage("Replayed and matched output message from journal", msg.messageType, msg.message);
                }
                this.console.info("Function completed successfully.");
                // Mark the end of the invocation
                this.send(new types_1.Message(protocol_1.END_MESSAGE_TYPE, new protocol_1.EndMessage()));
                this.finish(value);
            }
            catch (e) {
                this.unhandledError((0, errors_1.ensureError)(e));
            }
        })
            .catch((e) => {
            // because of how we try/catch in the promise handler above, this here exclusively handles
            // errors coming from the rpc function
            try {
                // Sometimes the function code fails as a consequence of the state machine encountering
                // an error before (possibly Restate closed the connection).
                if (this.stateMachineClosed) {
                    return;
                }
                this.sendErrorAndFinish((0, errors_1.ensureError)(e));
            }
            catch (ee) {
                this.unhandledError((0, errors_1.ensureError)(ee));
            }
        });
        // this promise here completes under any completion, including the cases where the
        // rpc function does not end (error, suspension, ...)
        return this.invocationComplete.promise;
    }
    async sendErrorAndFinish(e, ctx) {
        this.console.warn("Function completed with an error.\n", e);
        if (e instanceof errors_1.TerminalError) {
            this.sendTerminalError(e);
        }
        else {
            this.sendRetryableError(e, ctx);
        }
        await this.finish();
    }
    sendRetryableError(e, ctx) {
        const msg = new types_1.Message(protocol_1.ERROR_MESSAGE_TYPE, (0, errors_1.errorToErrorMessage)(e, ctx));
        this.console.debugJournalMessage("Invocation ended with retryable error.", msg.messageType, msg.message);
        this.send(msg);
    }
    sendTerminalError(e) {
        const msg = new types_1.Message(protocol_1.OUTPUT_ENTRY_MESSAGE_TYPE, new protocol_1.OutputEntryMessage({
            result: { case: "failure", value: e.toFailure() },
        }));
        this.console.debugJournalMessage("Invocation ended with failure message.", msg.messageType, msg.message);
        this.journal.handleUserSideMessage(msg.messageType, msg.message);
        if (!this.journal.outputMsgWasReplayed()) {
            this.send(msg);
        }
        // Mark the end of the invocation
        this.send(new types_1.Message(protocol_1.END_MESSAGE_TYPE, new protocol_1.EndMessage()));
    }
    send(message) {
        this.connection.send(message).catch((err) => {
            this.handleStreamError(err);
        });
    }
    /**
     * Closes the state machine, flushes all output, and resolves the invocation promise.
     */
    async finish(value) {
        try {
            this.stateMachineClosed = true;
            this.journal.close();
            this.clearSuspensionTimeout();
            await this.connection.end();
            this.invocationComplete.resolve(value);
        }
        catch (e) {
            this.invocationComplete.reject((0, errors_1.ensureError)(e));
        }
    }
    /**
     * This function propagates errors up to the completion promise, to be handled
     * on the connection layer.
     */
    unhandledError(e) {
        this.invocationComplete.reject(e);
        this.stateMachineClosed = true;
        this.journal.close();
        this.clearSuspensionTimeout();
    }
    /**
     * This method is invoked when we hit a suspension point. A suspension point is everytime the user "await"s a Promise returned by RestateContext that might be completed at a later point in time by a CompletionMessage/AckMessage.
     *
     * Depending on the state of the read channel, and on the protocol mode, it might either immediately suspend, or schedule a suspension to happen at a later point in time.
     */
    hitSuspensionPoint() {
        // If there was already a timeout set, we want to reset the time to postpone suspension as long as we make progress.
        // So we first clear the old timeout, and then we set a new one.
        this.clearSuspensionTimeout();
        const delay = this.getSuspensionMillis();
        this.console.debugJournalMessage("Scheduling suspension in " + delay + " ms");
        if (delay >= 0) {
            // Set a new suspension with a new timeout
            // The suspension will only be sent if the timeout is not canceled due to a completion.
            // In case the delay is 0 we still schedule a timeout in order to process the suspension on the next process tick,
            // without interrupting the current work.
            this.suspensionTimeout = setTimeout(() => {
                this.suspend();
            }, delay);
        }
    }
    // Suspension timeouts:
    // Lambda case: suspend immediately when control is back in the user code
    // Bidi streaming case:
    // - suspend after 1 seconds if input channel is still open (can still get completions)
    // - suspend immediately if input channel is closed (cannot get completions)
    getSuspensionMillis() {
        return this.protocolMode === discovery_1.ProtocolMode.REQUEST_RESPONSE ||
            this.inputChannelClosed
            ? 0
            : this.suspensionMillis;
    }
    async suspend() {
        const indices = this.journal.getCompletableIndices();
        // If the state is closed then we either already send a suspension
        // or something else bad happened...
        if (this.journal.isClosed() || indices.length === 0) {
            return;
        }
        // There need to be journal entries to complete, otherwise this timeout should have been removed.
        // A suspension message is the end of the invocation.
        // Resolve the root call with the suspension message
        // This will lead to a onCallSuccess call where this msg will be sent.
        const msg = new types_1.Message(protocol_1.SUSPENSION_MESSAGE_TYPE, new protocol_1.SuspensionMessage({
            entryIndexes: indices,
        }));
        this.console.debugJournalMessage("Writing suspension message to journal.", msg.messageType, msg.message);
        this.journal.handleUserSideMessage(msg.messageType, msg.message);
        if (!this.journal.outputMsgWasReplayed()) {
            this.send(msg);
        }
        this.console.info("Suspending function.");
        await this.finish();
    }
    /**
     * WARNING: make sure you use this at the right point in the code
     * After the index has been incremented...
     * This is error-prone... Would be good to have a better solution for this.
     */
    getUserCodeJournalIndex() {
        return this.journal.getUserCodeJournalIndex();
    }
    handleInputClosed() {
        if (this.journal.isClosed() ||
            this.stateMachineClosed ||
            this.inputChannelClosed) {
            return;
        }
        this.inputChannelClosed = true;
        this.console.debug("Restate closed connection to trigger suspension.");
        // If there is a timeout planned, reset the timout to execute immediately when the work is done.
        if (this.suspensionTimeout !== undefined) {
            this.hitSuspensionPoint();
        }
    }
    handleStreamError(e) {
        this.console.info("Aborting function execution and closing state machine due to connection error: " +
            e.message);
        this.unhandledError(e);
    }
    handleDanglingPromiseError(e) {
        this.console.info("Aborting function execution and closing state machine due to an error: " +
            e.message);
        this.unhandledError(e);
    }
    nextEntryWillBeReplayed() {
        return this.journal.nextEntryWillBeReplayed();
    }
    clearSuspensionTimeout() {
        if (this.suspensionTimeout !== undefined) {
            clearTimeout(this.suspensionTimeout);
            this.suspensionTimeout = undefined;
        }
    }
}
exports.StateMachine = StateMachine;
//# sourceMappingURL=state_machine.js.map