export type WrappedPromise<T> = Promise<T> & {
    transform: <TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => WrappedPromise<TResult1 | TResult2>;
};
export declare function wrapDeeply<T>(promise: Promise<T>, onThen?: () => void): WrappedPromise<T>;
export declare class CompletablePromise<T> {
    private success;
    private failure;
    readonly promise: Promise<T>;
    constructor();
    resolve(value: T): void;
    reject(reason?: any): void;
}
export declare const PROMISE_PENDING: Promise<any>;
export declare const WRAPPED_PROMISE_PENDING: Promise<any>;
//# sourceMappingURL=promises.d.ts.map