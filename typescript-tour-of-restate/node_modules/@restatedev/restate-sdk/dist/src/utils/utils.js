"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.equalityCheckers = exports.formatMessageAsJson = exports.jsonDeserialize = exports.jsonSerialize = void 0;
const protocol_1 = require("../types/protocol");
const node_buffer_1 = require("node:buffer");
function jsonSerialize(obj) {
    return JSON.stringify(obj, (_, v) => typeof v === "bigint" ? "BIGINT::" + v.toString() : v);
}
exports.jsonSerialize = jsonSerialize;
function jsonDeserialize(json) {
    return JSON.parse(json, (_, v) => typeof v === "string" && v.startsWith("BIGINT::")
        ? BigInt(v.substring(8))
        : v);
}
exports.jsonDeserialize = jsonDeserialize;
function formatMessageAsJson(obj) {
    const newObj = { ...obj };
    for (const [key, value] of Object.entries(newObj)) {
        if (node_buffer_1.Buffer.isBuffer(value)) {
            newObj[key] = value.toString().trim();
        }
    }
    // Stringify object. Replace bigintToString serializer to prevent "BigInt not serializable" errors
    return JSON.stringify(obj, (_, v) => typeof v === "bigint" ? v.toString() + "n" : v);
}
exports.formatMessageAsJson = formatMessageAsJson;
/**
 * Equality functions
 * @param msg1 the current message from user code
 * @param msg2 the replayed message
 */
// These functions are used to check whether a replayed message matches the current user code.
// We check the fields which we can check
// (the fields which do not contain results, because these might be filled in the result)
const eq = (a, b) => {
    const n = a.length;
    const m = b.length;
    if (n !== m) {
        return false;
    }
    for (let i = 0; i < n; i++) {
        if (a.at(i) !== b.at(i)) {
            return false;
        }
    }
    return true;
};
const getStateMsgEquality = (msg1, msg2) => {
    return eq(msg1.key, msg2.key);
};
const invokeMsgEquality = (msg1, msg2) => {
    return (msg1.serviceName === msg2.serviceName &&
        msg1.handlerName === msg2.handlerName &&
        eq(msg1.parameter, msg2.parameter));
};
const setStateMsgEquality = (msg1, msg2) => {
    return eq(msg1.key, msg2.key) && eq(msg1.value, msg2.value);
};
const clearStateMsgEquality = (msg1, msg2) => {
    return eq(msg1.key, msg2.key);
};
const completeAwakeableMsgEquality = (msg1, msg2) => {
    if (!(msg1.id === msg2.id)) {
        return false;
    }
    if (msg1.result.case === "value" &&
        msg2.result.case === "value" &&
        eq(msg1.result.value, msg2.result.value)) {
        return true;
    }
    else if (msg1.result.case === "failure" && msg2.result.case === "failure") {
        return (msg1.result.value.code === msg2.result.value.code &&
            msg1.result.value.message === msg2.result.value.message);
    }
    else {
        return false;
    }
};
const outputMsgEquality = (msg1, msg2) => {
    if (msg1.result.case === "value" &&
        msg2.result.case === "value" &&
        eq(msg1.result.value, msg2.result.value)) {
        return true;
    }
    else if (msg1.result.case === "failure" && msg2.result.case === "failure") {
        return (msg1.result.value.code === msg2.result.value.code &&
            msg1.result.value.message === msg2.result.value.message);
    }
    else {
        return false;
    }
};
exports.equalityCheckers = new Map([
    [protocol_1.GET_STATE_ENTRY_MESSAGE_TYPE, getStateMsgEquality],
    [protocol_1.SET_STATE_ENTRY_MESSAGE_TYPE, setStateMsgEquality],
    [protocol_1.CLEAR_STATE_ENTRY_MESSAGE_TYPE, clearStateMsgEquality],
    [protocol_1.INVOKE_ENTRY_MESSAGE_TYPE, invokeMsgEquality],
    [protocol_1.BACKGROUND_INVOKE_ENTRY_MESSAGE_TYPE, invokeMsgEquality],
    [protocol_1.COMPLETE_AWAKEABLE_ENTRY_MESSAGE_TYPE, completeAwakeableMsgEquality],
    [protocol_1.OUTPUT_ENTRY_MESSAGE_TYPE, outputMsgEquality],
    [protocol_1.AWAKEABLE_ENTRY_MESSAGE_TYPE, () => true],
    [protocol_1.SIDE_EFFECT_ENTRY_MESSAGE_TYPE, () => true],
    [protocol_1.SLEEP_ENTRY_MESSAGE_TYPE, () => true],
]);
//# sourceMappingURL=utils.js.map