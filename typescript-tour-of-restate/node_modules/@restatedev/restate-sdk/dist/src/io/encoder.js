"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeMessages = exports.encodeMessage = exports.streamEncoder = void 0;
const node_stream_1 = __importDefault(require("node:stream"));
const protocol_1 = require("../types/protocol");
const types_1 = require("../types/types");
const node_buffer_1 = require("node:buffer");
function streamEncoder() {
    return new node_stream_1.default.Transform({
        writableObjectMode: true,
        objectMode: true,
        transform(msg, _encoding, cb) {
            // We do not catch errors here because we want them to be handled at the Connection level,
            // so we can close the state machine.
            const result = encodeMessage(msg);
            cb(null, result);
        },
    });
}
exports.streamEncoder = streamEncoder;
function encodeMessage(msg) {
    return encodeMessages([msg]);
}
exports.encodeMessage = encodeMessage;
function encodeMessages(messages) {
    const chunks = [];
    for (const message of messages) {
        const pbType = protocol_1.PROTOBUF_MESSAGE_BY_TYPE.get(BigInt(message.messageType));
        if (pbType === undefined) {
            throw new Error("Trying to encode a message with unknown message type " +
                message.messageType);
        }
        const buf = message.message.toBinary();
        const header = new types_1.Header(BigInt(message.messageType), buf.length, message.completed, message.requiresAck);
        const header64 = header.toU64be();
        const headerBuf = node_buffer_1.Buffer.alloc(8);
        headerBuf.writeBigUInt64BE(header64);
        chunks.push(headerBuf);
        chunks.push(buf);
    }
    return node_buffer_1.Buffer.concat(chunks);
}
exports.encodeMessages = encodeMessages;
//# sourceMappingURL=encoder.js.map