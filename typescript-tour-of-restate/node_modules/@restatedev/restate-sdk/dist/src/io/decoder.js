"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeMessagesBuffer = exports.decodeLambdaBody = exports.streamDecoder = void 0;
// This is a NodeJs stream transformer. It is used to convert a chunked stream of bytes to
// a stream of JavaScript objects of the form { header: .. , message: ..} where:
// * header has some information about the frame like, the message type, and some flags.
// * message is the Protobuf decoded message.
//
// To use this one would need to do the following:
//
// let decodedStream = stream.pipe(streamDecoder());
//
// at this point the decodedStream is a high level stream of objects {header, message}
const node_stream_1 = __importDefault(require("node:stream"));
const protocol_1 = require("../types/protocol");
const types_1 = require("../types/types");
const node_assert_1 = __importDefault(require("node:assert"));
const errors_1 = require("../types/errors");
const node_buffer_1 = require("node:buffer");
const WAITING_FOR_HEADER = 0;
const WAITING_FOR_BODY = 1;
function initalDecoderState(buf) {
    return {
        state: WAITING_FOR_HEADER,
        header: undefined,
        buf,
    };
}
function appendBufferToDecoder(state, chunk) {
    state.buf = node_buffer_1.Buffer.concat([state.buf, chunk]);
}
function decodeMessages(decoderState, out) {
    let buf = decoderState.buf;
    while (buf.length > 0 || decoderState.state === WAITING_FOR_BODY) {
        switch (decoderState.state) {
            case WAITING_FOR_HEADER: {
                (0, node_assert_1.default)(decoderState.header === undefined);
                if (buf.length < 8) {
                    decoderState.buf = buf;
                    return decoderState;
                }
                const h = buf.readBigUInt64BE();
                buf = buf.subarray(8);
                const materializedHeader = types_1.Header.fromU64be(h);
                decoderState.header = materializedHeader;
                decoderState.state = WAITING_FOR_BODY;
                break;
            }
            case WAITING_FOR_BODY: {
                const header = decoderState.header;
                (0, node_assert_1.default)(header !== undefined);
                if (buf.length < header.frameLength) {
                    decoderState.buf = buf;
                    return decoderState;
                }
                const frame = buf.subarray(0, header.frameLength);
                buf = buf.subarray(header.frameLength);
                decoderState.state = WAITING_FOR_HEADER;
                decoderState.header = undefined;
                const pbType = protocol_1.PROTOBUF_MESSAGE_BY_TYPE.get(header.messageType);
                if (pbType === undefined) {
                    throw new Error("Got unknown message type " + header.messageType);
                }
                else {
                    //eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const message = pbType.fromBinary(frame);
                    out.push(new types_1.Message(header.messageType, message, header.completedFlag, header.requiresAckFlag));
                }
                break;
            }
        }
    }
    decoderState.buf = buf;
    return decoderState;
}
function streamDecoder() {
    let decoderState = initalDecoderState(node_buffer_1.Buffer.alloc(0));
    return new node_stream_1.default.Transform({
        writableObjectMode: true,
        objectMode: true,
        transform(chunk, _encoding, cb) {
            try {
                appendBufferToDecoder(decoderState, chunk);
                decoderState = decodeMessages(decoderState, this);
                cb();
            }
            catch (e) {
                cb((0, errors_1.ensureError)(e), null);
            }
        },
    });
}
exports.streamDecoder = streamDecoder;
// Decodes messages from Lambda requests to an array of headers + protocol messages
const base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
function decodeLambdaBody(msgBase64) {
    if (!base64regex.test(msgBase64)) {
        throw new Error("Cannot parse the lambda request body, body was not valid base64 encoded: " +
            msgBase64);
    }
    const buffer = node_buffer_1.Buffer.from(msgBase64, "base64");
    return decodeMessagesBuffer(buffer);
}
exports.decodeLambdaBody = decodeLambdaBody;
function decodeMessagesBuffer(buffer) {
    const decodedEntries = [];
    let finalState;
    try {
        finalState = decodeMessages(initalDecoderState(buffer), decodedEntries);
    }
    catch (e) {
        const err = (0, errors_1.ensureError)(e);
        throw new Error("Cannot parse the lambda request body, message was not a valid sequence of Restate messages: " +
            err.message, { cause: err });
    }
    if (finalState.buf.length > 0) {
        throw new Error("Cannot parse the request body: Trailing data (incomplete message) in request body: " +
            finalState.buf.toString("hex"));
    }
    return decodedEntries;
}
exports.decodeMessagesBuffer = decodeMessagesBuffer;
//# sourceMappingURL=decoder.js.map