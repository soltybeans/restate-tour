"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BufferedConnection = void 0;
const encoder_1 = require("../io/encoder");
class BufferedConnection {
    flushFn;
    queue = [];
    flushing = Promise.resolve();
    constructor(flushFn) {
        this.flushFn = flushFn;
    }
    send(msg) {
        const len = this.queue.push(msg);
        if (len === 1) {
            // we are the first in line, therefore we schedule a flush,
            // BUT we must wait for the previous flush to end.
            this.flushing = this.flushing.then(() => this.scheduleFlush());
        }
        // we don't need to reschedule the `flush` here,
        // because the flush happens anyway at the end of the current event loop iteration.
        // tag along to the previously scheduled flush.
        return this.flushing;
    }
    end() {
        this.flushing = this.flushing.then(() => this.flush());
        return this.flushing;
    }
    scheduleFlush() {
        // schedule a flush at the end of the current event loop iteration.
        return new Promise((resolve, reject) => setImmediate(() => {
            this.flush().then(resolve).catch(reject);
        }));
    }
    async flush() {
        if (this.queue.length === 0) {
            return Promise.resolve();
        }
        const buffer = (0, encoder_1.encodeMessages)(this.queue);
        this.queue = [];
        return this.flushFn(buffer);
    }
}
exports.BufferedConnection = BufferedConnection;
//# sourceMappingURL=buffered_connection.js.map