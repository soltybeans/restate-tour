"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LambdaConnection = void 0;
const encoder_1 = require("../io/encoder");
const protocol_1 = require("../types/protocol");
const logger_1 = require("../logger");
const node_buffer_1 = require("node:buffer");
const RESOLVED = Promise.resolve();
class LambdaConnection {
    attemptHeaders;
    suspendedOrCompleted;
    // Empty buffer to store journal output messages
    outputBuffer = node_buffer_1.Buffer.alloc(0);
    // Callback to resolve the invocation promise of the Lambda handler when the response is ready
    completionPromise;
    resolveOnCompleted;
    constructor(attemptHeaders, suspendedOrCompleted = false) {
        this.attemptHeaders = attemptHeaders;
        this.suspendedOrCompleted = suspendedOrCompleted;
        // Promise that signals when the invocation is over, to then flush the messages
        this.completionPromise = new Promise((resolve) => {
            this.resolveOnCompleted = resolve;
        });
    }
    headers() {
        return new Map(Object.entries(this.attemptHeaders));
    }
    // Send a message back to the runtime
    send(msg) {
        // Add the header and the body to buffer and add to the output buffer
        const msgBuffer = (0, encoder_1.encodeMessage)(msg);
        this.outputBuffer = node_buffer_1.Buffer.concat([this.outputBuffer, msgBuffer]);
        // An output message, suspension message or error message is the end of a Lambda invocation
        if (msg.messageType === protocol_1.OUTPUT_ENTRY_MESSAGE_TYPE ||
            msg.messageType === protocol_1.SUSPENSION_MESSAGE_TYPE ||
            msg.messageType === protocol_1.ERROR_MESSAGE_TYPE) {
            this.suspendedOrCompleted = true;
        }
        return RESOLVED;
    }
    getResult() {
        return this.completionPromise;
    }
    end() {
        if (this.suspendedOrCompleted) {
            logger_1.rlog.debug("Flushing output buffer...");
            this.resolveOnCompleted(this.outputBuffer);
        }
        this.outputBuffer = node_buffer_1.Buffer.alloc(0);
        return RESOLVED;
    }
}
exports.LambdaConnection = LambdaConnection;
//# sourceMappingURL=lambda_connection.js.map