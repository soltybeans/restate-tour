"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestateHttp2Connection = void 0;
const decoder_1 = require("../io/decoder");
const logger_1 = require("../logger");
const promises_1 = require("node:stream/promises");
const buffered_connection_1 = require("./buffered_connection");
// utility promise, for cases where we want to save allocation of an extra promise
const RESOLVED = Promise.resolve();
/**
 * A duplex stream with Restate Messages over HTTP2.
 *
 * This stream handles the following concerns:
 *
 * (1) encoding and decoding of messages from  and from raw bytes
 *
 * (2) buffering the outgoing messages, because the call sites that produce (potentially) large
 *     messages might not await their transfer. Aside from the fact that we achieve better pipelining
 *     that way, we also simply cannot guarantee that users of the Restate SDK actually await the
 *     relevant async API methods.
 *
 *     This stream essentially buffers messages and, upon flush, sends them asynchronously, as the
 *     stream has availability. Flush requests queue up, if new data gets flushed while the previous
 *     data is still being sent.
 *
 * (3) Input messages can be pipelined to a sequence of consumers. For example, first to a journal,
 *     and afterwards to the state machine.
 *
 * (4) Handling the relevant stream events for errors and consolidating them to one error handler, plus
 *     notifications for cleanly closed input (to trigger suspension).
 */
class RestateHttp2Connection {
    attemptHeaders;
    rawStream;
    /**
     * create a RestateDuplex stream from an http2 (duplex) stream.
     */
    static from(request, http2stream) {
        return new RestateHttp2Connection(request.headers, http2stream);
    }
    // --------------------------------------------------------------------------
    // input as decoded messages
    sdkInput;
    // consumer handling
    currentConsumer = null;
    inputBuffer = [];
    consumerError;
    consumerInputClosed = false;
    outputBuffer;
    constructor(attemptHeaders, rawStream) {
        this.attemptHeaders = attemptHeaders;
        this.rawStream = rawStream;
        this.sdkInput = rawStream.pipe((0, decoder_1.streamDecoder)());
        this.outputBuffer = new buffered_connection_1.BufferedConnection((buffer) => {
            const hasMoreCapacity = rawStream.write(buffer);
            if (hasMoreCapacity) {
                return RESOLVED;
            }
            else {
                return new Promise((resolve) => rawStream.once("drain", resolve));
            }
        });
        // remember and forward messages
        this.sdkInput.on("data", (m) => {
            // deliver message, if we have a consumer. otherwise buffer the message.
            if (this.currentConsumer) {
                if (this.currentConsumer.handleMessage(m)) {
                    this.removeCurrentConsumer();
                }
            }
            else {
                this.inputBuffer.push(m);
            }
        });
        // remember and forward close events
        this.sdkInput.on("end", () => {
            this.consumerInputClosed = true;
            if (this.currentConsumer) {
                this.currentConsumer.handleInputClosed();
            }
        });
        // --------- error handling --------
        // - a.k.a. node event wrangling...
        // the error handler for all sorts of errors coming from streams
        const errorHandler = (e) => {
            // make sure we don't overwrite the initial error
            if (this.consumerError !== undefined) {
                return;
            }
            this.consumerError = e;
            if (this.currentConsumer) {
                this.currentConsumer.handleStreamError(e);
            }
        };
        // those two event types should cover all types of connection losses
        rawStream.on("aborted", () => {
            logger_1.rlog.error("Connection to Restate was lost");
            errorHandler(new Error("Connection to Restate was lost"));
        });
        // this is both the raw http2 stream and the output SDK->Restate
        rawStream.on("error", (e) => {
            logger_1.rlog.error("Error in http2 stream to Restate: " + (e.stack ?? e.message));
            errorHandler(e);
        });
        // these events notify of errors in the decoding pipeline
        this.sdkInput.on("error", (e) => {
            logger_1.rlog.error("Error in input stream (Restate to Service): " + (e.stack ?? e.message));
            errorHandler(e);
        });
        // see if streams get torn down before they end cleanly
        this.sdkInput.on("close", () => {
            if (!this.consumerInputClosed) {
                errorHandler(new Error("stream was destroyed before end"));
            }
        });
    }
    headers() {
        return new Map(Object.entries(this.attemptHeaders));
    }
    // --------------------------------------------------------------------------
    //  input stream handling
    // --------------------------------------------------------------------------
    /**
     * Pipes the messages from this connection to the given consumer. The consumer
     * will also receive error and stream closing notifications.
     *
     * Once the 'handleMessage()' method returns 'true', the consumer is immediately removed.
     * That way, consumers can consume a bounded amount of messages (like just the initial journal).
     *
     * There can only be one consumer at a time.
     */
    pipeToConsumer(consumer) {
        if (this.currentConsumer !== null) {
            throw new Error("Already piping to a consumer");
        }
        this.currentConsumer = consumer;
        // propagate pre-existing information
        if (this.consumerError) {
            consumer.handleStreamError(this.consumerError);
        }
        if (this.consumerInputClosed) {
            consumer.handleInputClosed();
        }
        // pipe the buffered input messages, if we buffered some before the consumer was registered
        const input = this.inputBuffer;
        if (input.length > 0) {
            let i = 0;
            while (i < input.length) {
                const done = consumer.handleMessage(input[i]);
                i++;
                if (done) {
                    this.removeCurrentConsumer();
                    break;
                }
            }
            this.inputBuffer = i === input.length ? [] : this.inputBuffer.slice(i);
        }
    }
    /**
     * Removes the current consumer, if there is one.
     */
    removeCurrentConsumer() {
        this.currentConsumer = null;
    }
    // --------------------------------------------------------------------------
    //  output stream handling
    // --------------------------------------------------------------------------
    /**
     * Adds a message to the output stream.
     *
     * This always puts the message into the node stream, but will return a promise that is resolved once
     * further messages can be written.
     *
     * The reasoning is that some, but not all Restate operations return promises and are typically
     * awaited. For example, rpc, sleep, side-effect have promises and are awaited, while one-way-sends and
     * state updates don't return promises.
     *
     * As a pragmatic solution, we always accept messages, but return a promise for when the output has
     * capacity again, so that at least the operations that await results will respect backpressure.
     */
    send(msg) {
        return this.outputBuffer.send(msg);
    }
    /**
     * Ends the stream, awaiting pending writes.
     */
    async end() {
        await this.outputBuffer.end();
        this.rawStream.end();
        const options = {
            error: true,
            cleanup: true,
        };
        await (0, promises_1.finished)(this.rawStream, options);
    }
}
exports.RestateHttp2Connection = RestateHttp2Connection;
//# sourceMappingURL=http_connection.js.map