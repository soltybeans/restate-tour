/// <reference types="node" />
/// <reference types="node" />
import stream from "node:stream";
import { Connection, RestateStreamConsumer } from "./connection";
import { Message } from "../types/types";
import { Http2ServerRequest, IncomingHttpHeaders } from "node:http2";
/**
 * A duplex stream with Restate Messages over HTTP2.
 *
 * This stream handles the following concerns:
 *
 * (1) encoding and decoding of messages from  and from raw bytes
 *
 * (2) buffering the outgoing messages, because the call sites that produce (potentially) large
 *     messages might not await their transfer. Aside from the fact that we achieve better pipelining
 *     that way, we also simply cannot guarantee that users of the Restate SDK actually await the
 *     relevant async API methods.
 *
 *     This stream essentially buffers messages and, upon flush, sends them asynchronously, as the
 *     stream has availability. Flush requests queue up, if new data gets flushed while the previous
 *     data is still being sent.
 *
 * (3) Input messages can be pipelined to a sequence of consumers. For example, first to a journal,
 *     and afterwards to the state machine.
 *
 * (4) Handling the relevant stream events for errors and consolidating them to one error handler, plus
 *     notifications for cleanly closed input (to trigger suspension).
 */
export declare class RestateHttp2Connection implements Connection {
    private readonly attemptHeaders;
    private readonly rawStream;
    /**
     * create a RestateDuplex stream from an http2 (duplex) stream.
     */
    static from(request: Http2ServerRequest, http2stream: stream.Duplex): RestateHttp2Connection;
    private readonly sdkInput;
    private currentConsumer;
    private inputBuffer;
    private consumerError?;
    private consumerInputClosed;
    private outputBuffer;
    constructor(attemptHeaders: IncomingHttpHeaders, rawStream: stream.Duplex);
    headers(): ReadonlyMap<string, string | string[] | undefined>;
    /**
     * Pipes the messages from this connection to the given consumer. The consumer
     * will also receive error and stream closing notifications.
     *
     * Once the 'handleMessage()' method returns 'true', the consumer is immediately removed.
     * That way, consumers can consume a bounded amount of messages (like just the initial journal).
     *
     * There can only be one consumer at a time.
     */
    pipeToConsumer(consumer: RestateStreamConsumer): void;
    /**
     * Removes the current consumer, if there is one.
     */
    removeCurrentConsumer(): void;
    /**
     * Adds a message to the output stream.
     *
     * This always puts the message into the node stream, but will return a promise that is resolved once
     * further messages can be written.
     *
     * The reasoning is that some, but not all Restate operations return promises and are typically
     * awaited. For example, rpc, sleep, side-effect have promises and are awaited, while one-way-sends and
     * state updates don't return promises.
     *
     * As a pragmatic solution, we always accept messages, but return a promise for when the output has
     * capacity again, so that at least the operations that await results will respect backpressure.
     */
    send(msg: Message): Promise<void>;
    /**
     * Ends the stream, awaiting pending writes.
     */
    end(): Promise<void>;
}
//# sourceMappingURL=http_connection.d.ts.map