"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Http2Handler = void 0;
const node_stream_1 = __importDefault(require("node:stream"));
const promises_1 = require("node:stream/promises");
const http_connection_1 = require("../connection/http_connection");
const errors_1 = require("../types/errors");
const invocation_1 = require("../invocation");
const state_machine_1 = require("../state_machine");
const logger_1 = require("../logger");
const components_1 = require("../types/components");
const discovery_1 = require("../types/discovery");
const validate_1 = require("./request_signing/validate");
const user_agent_1 = require("../user_agent");
const protocol_1 = require("../types/protocol");
const discovery_pb_1 = require("../generated/proto/discovery_pb");
class Http2Handler {
    endpoint;
    constructor(endpoint) {
        this.endpoint = endpoint;
    }
    acceptConnection(request, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _response) {
        const stream = request.stream;
        const url = new URL(request.url ?? "/", "https://restate.dev"); // use a dummy base; we only care about path
        this.validateConnectionSignature(request, url, stream)
            .then((result) => {
            if (!result) {
                return;
            }
            else {
                return this.handleConnection(request, url, stream);
            }
        })
            .catch((e) => {
            const error = (0, errors_1.ensureError)(e);
            logger_1.rlog.error("Error while handling connection: " + (error.stack ?? error.message));
            stream.end();
            stream.destroy();
        });
    }
    async validateConnectionSignature(request, url, stream) {
        if (!this.endpoint.keySet) {
            // not validating
            return true;
        }
        const keySet = this.endpoint.keySet;
        const validateResponse = await (0, validate_1.validateRequestSignature)(keySet, url.pathname ?? "/", request.headers);
        if (!validateResponse.valid) {
            logger_1.rlog.error(`Rejecting request as its JWT did not validate: ${validateResponse.error}`);
            stream.respond({
                "content-type": "application/restate",
                "x-restate-server": user_agent_1.X_RESTATE_SERVER,
                ":status": 401,
            });
            stream.end();
            stream.destroy();
            return false;
        }
        else {
            return true;
        }
    }
    handleConnection(request, url, stream) {
        const route = (0, components_1.parseUrlComponents)(url.pathname ?? undefined);
        if (!route) {
            return respondNotFound(stream);
        }
        if (route === "discovery") {
            const acceptVersionsString = request.headers["accept"];
            const serviceDiscoveryProtocolVersion = (0, protocol_1.selectSupportedServiceDiscoveryProtocolVersion)(acceptVersionsString);
            if (serviceDiscoveryProtocolVersion ==
                discovery_pb_1.ServiceDiscoveryProtocolVersion.SERVICE_DISCOVERY_PROTOCOL_VERSION_UNSPECIFIED) {
                const errorMessage = `Unsupported service discovery protocol version '${acceptVersionsString}'`;
                logger_1.rlog.warn(errorMessage);
                return respondUnsupportedProtocolVersion(stream, errorMessage);
            }
            const discovery = this.endpoint.computeDiscovery(discovery_1.ProtocolMode.BIDI_STREAM);
            return respondDiscovery(serviceDiscoveryProtocolVersion, discovery, stream);
        }
        const serviceProtocolVersionString = request.headers["content-type"];
        const serviceProtocolVersion = (0, protocol_1.parseServiceProtocolVersion)(serviceProtocolVersionString);
        if (!(0, protocol_1.isServiceProtocolVersionSupported)(serviceProtocolVersion)) {
            const errorMessage = `Unsupported service protocol version '${serviceProtocolVersionString}'`;
            logger_1.rlog.warn(errorMessage);
            return respondUnsupportedProtocolVersion(stream, errorMessage);
        }
        const urlComponents = route;
        const component = this.endpoint.componentByName(urlComponents.componentName);
        if (!component) {
            return respondNotFound(stream);
        }
        const handler = component.handlerMatching(urlComponents);
        if (!handler) {
            return respondNotFound(stream);
        }
        // valid connection, let's dispatch the invocation
        stream.respond({
            "content-type": (0, protocol_1.serviceProtocolVersionToHeaderValue)(serviceProtocolVersion),
            "x-restate-server": user_agent_1.X_RESTATE_SERVER,
            ":status": 200,
        });
        const restateStream = http_connection_1.RestateHttp2Connection.from(request, stream);
        return handleInvocation(handler, restateStream);
    }
}
exports.Http2Handler = Http2Handler;
function respondUnsupportedProtocolVersion(stream, errorMessage) {
    stream.respond({
        ":status": 415,
        "content-type": "text/plain",
        "x-restate-server": user_agent_1.X_RESTATE_SERVER,
    });
    stream.end(errorMessage);
    return (0, promises_1.finished)(stream);
}
function respondDiscovery(serviceDiscoveryProtocolVersion, response, http2Stream) {
    let responseData;
    if (serviceDiscoveryProtocolVersion === discovery_pb_1.ServiceDiscoveryProtocolVersion.V1) {
        responseData = JSON.stringify(response);
    }
    else {
        // should not be reached since we check for compatibility before
        throw new Error(`Unsupported service discovery protocol version: ${serviceDiscoveryProtocolVersion}`);
    }
    http2Stream.respond({
        ":status": 200,
        "content-type": (0, protocol_1.serviceDiscoveryProtocolVersionToHeaderValue)(serviceDiscoveryProtocolVersion),
        "x-restate-server": user_agent_1.X_RESTATE_SERVER,
    });
    return (0, promises_1.pipeline)(node_stream_1.default.Readable.from(responseData), http2Stream, {
        end: true,
    });
}
function respondNotFound(stream) {
    stream.respond({
        "content-type": "application/json",
        "x-restate-server": user_agent_1.X_RESTATE_SERVER,
        ":status": 404,
    });
    stream.end();
    return (0, promises_1.finished)(stream);
}
async function handleInvocation(handler, connection) {
    // step 1: collect all journal events
    const journalBuilder = new invocation_1.InvocationBuilder(handler);
    connection.pipeToConsumer(journalBuilder);
    try {
        await journalBuilder.completion();
    }
    finally {
        // ensure GC friendliness, also in case of errors
        connection.removeCurrentConsumer();
    }
    // step 2: create the state machine
    const invocation = journalBuilder.build();
    const stateMachine = new state_machine_1.StateMachine(connection, invocation, discovery_1.ProtocolMode.BIDI_STREAM, handler.kind(), invocation.inferLoggerContext());
    connection.pipeToConsumer(stateMachine);
    // step 3: invoke the function
    // This call would propagate errors in the state machine logic, but not errors
    // in the application function code. Ending a function with an error as well
    // as failign an invocation and being retried are perfectly valid actions from the
    // SDK's perspective.
    try {
        await stateMachine.invoke();
    }
    finally {
        // ensure GC friendliness, also in case of errors
        connection.removeCurrentConsumer();
    }
}
//# sourceMappingURL=http2_handler.js.map