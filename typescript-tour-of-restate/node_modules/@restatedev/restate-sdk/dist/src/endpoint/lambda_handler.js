"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LambdaHandler = void 0;
const logger_1 = require("../logger");
const lambda_connection_1 = require("../connection/lambda_connection");
const invocation_1 = require("../invocation");
const decoder_1 = require("../io/decoder");
const state_machine_1 = require("../state_machine");
const errors_1 = require("../types/errors");
const protocol_1 = require("../types/protocol");
const discovery_1 = require("../types/discovery");
const components_1 = require("../types/components");
const validate_1 = require("./request_signing/validate");
const user_agent_1 = require("../user_agent");
const node_buffer_1 = require("node:buffer");
const discovery_pb_1 = require("../generated/proto/discovery_pb");
class LambdaHandler {
    endpoint;
    constructor(endpoint) {
        this.endpoint = endpoint;
    }
    // --------------------------------------------------------------------------
    /**
     * This is the main request handling method, effectively a typed variant of `create()`.
     */
    async handleRequest(event, context) {
        const path = "path" in event ? event.path : event.rawPath;
        const error = await this.validateConnectionSignature(path, event.headers);
        if (error !== null) {
            return error;
        }
        const parsed = (0, components_1.parseUrlComponents)(path);
        if (!parsed) {
            const msg = `Invalid path: path doesn't end in /invoke/SvcName/handlerName and also not in /discover: ${path}`;
            logger_1.rlog.trace(msg);
            return this.toErrorResponse(404, msg);
        }
        if (parsed === "discovery") {
            return this.handleDiscovery(event.headers["accept"]);
        }
        const serviceProtocolVersionString = event.headers["content-type"];
        const serviceProtocolVersion = (0, protocol_1.parseServiceProtocolVersion)(serviceProtocolVersionString);
        if (!(0, protocol_1.isServiceProtocolVersionSupported)(serviceProtocolVersion)) {
            const errorMessage = `Unsupported service protocol version '${serviceProtocolVersionString}'`;
            logger_1.rlog.warn(errorMessage);
            return this.toErrorResponse(415, errorMessage);
        }
        const parsedUrl = parsed;
        const method = this.endpoint.componentByName(parsedUrl.componentName);
        if (!method) {
            const msg = `No service found for URL: ${parsedUrl}`;
            logger_1.rlog.error(msg);
            return this.toErrorResponse(404, msg);
        }
        const handler = method?.handlerMatching(parsedUrl);
        if (!handler) {
            const msg = `No service found for URL: ${parsedUrl}`;
            logger_1.rlog.error(msg);
            return this.toErrorResponse(404, msg);
        }
        if (!event.body) {
            throw new Error("The incoming message body was null");
        }
        return this.handleInvoke(handler, event.body, event.headers, context, serviceProtocolVersion);
    }
    async validateConnectionSignature(path, headers) {
        if (!this.endpoint.keySet) {
            // not validating
            return null;
        }
        try {
            const validateResponse = await (0, validate_1.validateRequestSignature)(this.endpoint.keySet, path, headers);
            if (!validateResponse.valid) {
                logger_1.rlog.error(`Rejecting request as its JWT did not validate: ${validateResponse.error}`);
                return this.toErrorResponse(401, "Unauthorized");
            }
            else {
                return null;
            }
        }
        catch (e) {
            const error = (0, errors_1.ensureError)(e);
            logger_1.rlog.error("Error while attempting to validate request signature: " +
                (error.stack ?? error.message));
            return this.toErrorResponse(401, "Unauthorized");
        }
    }
    async handleInvoke(handler, body, headers, context, serviceProtocolVersion) {
        try {
            // build the previous journal from the events
            let decodedEntries = (0, decoder_1.decodeLambdaBody)(body);
            const journalBuilder = new invocation_1.InvocationBuilder(handler);
            decodedEntries.forEach((e) => journalBuilder.handleMessage(e));
            const alreadyCompleted = decodedEntries.find((e) => e.messageType === protocol_1.OUTPUT_ENTRY_MESSAGE_TYPE) !== undefined;
            decodedEntries = null;
            // set up and invoke the state machine
            const connection = new lambda_connection_1.LambdaConnection(headers, alreadyCompleted);
            const invocation = journalBuilder.build();
            const stateMachine = new state_machine_1.StateMachine(connection, invocation, discovery_1.ProtocolMode.REQUEST_RESPONSE, handler.kind(), invocation.inferLoggerContext({
                AWSRequestId: context.awsRequestId,
            }));
            await stateMachine.invoke();
            const result = await connection.getResult();
            return {
                headers: {
                    "content-type": (0, protocol_1.serviceProtocolVersionToHeaderValue)(serviceProtocolVersion),
                    "x-restate-server": user_agent_1.X_RESTATE_SERVER,
                },
                statusCode: 200,
                isBase64Encoded: true,
                body: encodeResponse(result),
            };
        }
        catch (e) {
            const error = (0, errors_1.ensureError)(e);
            logger_1.rlog.error(error.message);
            logger_1.rlog.error(error.stack);
            return this.toErrorResponse(500, error.message);
        }
    }
    handleDiscovery(acceptVersionsString) {
        const serviceDiscoveryProtocolVersion = (0, protocol_1.selectSupportedServiceDiscoveryProtocolVersion)(acceptVersionsString);
        if (serviceDiscoveryProtocolVersion ===
            discovery_pb_1.ServiceDiscoveryProtocolVersion.SERVICE_DISCOVERY_PROTOCOL_VERSION_UNSPECIFIED) {
            const errorMessage = `Unsupported service discovery protocol version '${acceptVersionsString}'`;
            logger_1.rlog.warn(errorMessage);
            return this.toErrorResponse(415, errorMessage);
        }
        const discovery = this.endpoint.computeDiscovery(discovery_1.ProtocolMode.REQUEST_RESPONSE);
        let body;
        if (serviceDiscoveryProtocolVersion === discovery_pb_1.ServiceDiscoveryProtocolVersion.V1) {
            const discoveryJson = JSON.stringify(discovery);
            body = node_buffer_1.Buffer.from(discoveryJson).toString("base64");
        }
        else {
            // should not be reached since we check for compatibility before
            throw new Error(`Unsupported service discovery protocol version: ${serviceDiscoveryProtocolVersion}`);
        }
        return {
            headers: {
                "content-type": (0, protocol_1.serviceDiscoveryProtocolVersionToHeaderValue)(serviceDiscoveryProtocolVersion),
                "x-restate-server": user_agent_1.X_RESTATE_SERVER,
            },
            statusCode: 200,
            isBase64Encoded: true,
            body,
        };
    }
    toErrorResponse(code, message) {
        return {
            headers: {
                "content-type": "text/plain",
                "x-restate-server": user_agent_1.X_RESTATE_SERVER,
            },
            statusCode: code,
            isBase64Encoded: true,
            body: encodeResponse(node_buffer_1.Buffer.from(JSON.stringify({ message }))),
        };
    }
}
exports.LambdaHandler = LambdaHandler;
function encodeResponse(data) {
    const buffer = data instanceof node_buffer_1.Buffer ? data : node_buffer_1.Buffer.from(data);
    return buffer.toString("base64");
}
//# sourceMappingURL=lambda_handler.js.map