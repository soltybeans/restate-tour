"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndpointImpl = exports.endpointImpl = void 0;
const rpc_1 = require("../types/rpc");
const logger_1 = require("../logger");
const http2_1 = __importDefault(require("http2"));
const http2_handler_1 = require("./http2_handler");
const lambda_handler_1 = require("./lambda_handler");
const components_1 = require("../types/components");
const v1_1 = require("./request_signing/v1");
function isServiceDefinition(m) {
    return m && m.service;
}
function isObjectDefinition(m) {
    return m && m.object;
}
function isWorkflowDefinition(m) {
    return m && m.workflow;
}
const endpointImpl = () => new EndpointImpl();
exports.endpointImpl = endpointImpl;
class EndpointImpl {
    services = new Map();
    _keySet;
    get keySet() {
        return this._keySet;
    }
    componentByName(componentName) {
        return this.services.get(componentName);
    }
    addComponent(component) {
        this.services.set(component.name(), component);
    }
    bindBundle(services) {
        services.registerServices(this);
        return this;
    }
    bind(definition) {
        if (isServiceDefinition(definition)) {
            const { name, service } = definition;
            if (!service) {
                throw new TypeError(`no service implementation found.`);
            }
            this.bindServiceComponent(name, service);
        }
        else if (isObjectDefinition(definition)) {
            const { name, object } = definition;
            if (!object) {
                throw new TypeError(`no object implementation found.`);
            }
            this.bindVirtualObjectComponent(name, object);
        }
        else if (isWorkflowDefinition(definition)) {
            const { name, workflow } = definition;
            if (!workflow) {
                throw new TypeError(`no workflow implementation found.`);
            }
            this.bindWorkflowObjectComponent(name, workflow);
        }
        else {
            throw new TypeError("can only bind a service or a virtual object or a workflow definition");
        }
        return this;
    }
    withIdentityV1(...keys) {
        if (!this._keySet) {
            this._keySet = (0, v1_1.parseKeySetV1)(keys);
            return this;
        }
        (0, v1_1.parseKeySetV1)(keys).forEach((buffer, key) => this._keySet?.set(key, buffer));
        return this;
    }
    http2Handler() {
        if (!this._keySet) {
            if (globalThis.process.env.NODE_ENV == "production") {
                logger_1.rlog.warn(`Accepting HTTP requests without validating request signatures; endpoint access must be restricted`);
            }
        }
        else {
            logger_1.rlog.info(`Validating HTTP requests using signing keys [${Array.from(this._keySet.keys())}]`);
        }
        const handler = new http2_handler_1.Http2Handler(this);
        return handler.acceptConnection.bind(handler);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    lambdaHandler() {
        if (!this._keySet) {
            logger_1.rlog.warn(`Accepting Lambda requests without validating request signatures; Invoke permissions must be restricted`);
        }
        else {
            logger_1.rlog.info(`Validating Lambda requests using signing keys [${Array.from(this._keySet.keys())}]`);
        }
        const handler = new lambda_handler_1.LambdaHandler(this);
        return handler.handleRequest.bind(handler);
    }
    listen(port) {
        const actualPort = port ?? parseInt(process.env.PORT ?? "9080");
        logger_1.rlog.info(`Listening on ${actualPort}...`);
        const server = http2_1.default.createServer(this.http2Handler());
        return new Promise((resolve, reject) => {
            let failed = false;
            server.once("error", (e) => {
                failed = true;
                reject(e);
            });
            server.listen(actualPort, () => {
                if (failed) {
                    return;
                }
                const address = server.address();
                if (address === null || typeof address === "string") {
                    reject(new TypeError("endpoint.listen() currently supports only binding to a PORT"));
                }
                else {
                    resolve(address.port);
                }
            });
        });
    }
    computeDiscovery(protocolMode) {
        const services = [...this.services.values()].map((c) => c.discovery());
        const endpoint = {
            protocolMode,
            minProtocolVersion: 1,
            maxProtocolVersion: 2,
            services,
        };
        return endpoint;
    }
    bindServiceComponent(name, router) {
        if (name.indexOf("/") !== -1) {
            throw new Error("service name must not contain any slash '/'");
        }
        const component = new components_1.ServiceComponent(name);
        for (const [route, handler] of Object.entries(router)) {
            const wrapper = rpc_1.HandlerWrapper.fromHandler(handler);
            if (!wrapper) {
                throw new TypeError(`${route} is not a restate handler.`);
            }
            wrapper.bindInstance(router);
            component.add(route, wrapper);
        }
        this.addComponent(component);
    }
    bindVirtualObjectComponent(name, router) {
        if (name.indexOf("/") !== -1) {
            throw new Error("service name must not contain any slash '/'");
        }
        const component = new components_1.VirtualObjectComponent(name);
        for (const [route, handler] of Object.entries(router)) {
            const wrapper = rpc_1.HandlerWrapper.fromHandler(handler);
            if (!wrapper) {
                throw new TypeError(`${route} is not a restate handler.`);
            }
            wrapper.bindInstance(router);
            component.add(route, wrapper);
        }
        this.addComponent(component);
    }
    bindWorkflowObjectComponent(name, workflow) {
        if (name.indexOf("/") !== -1) {
            throw new Error("service name must not contain any slash '/'");
        }
        const component = new components_1.WorkflowComponent(name);
        for (const [route, handler] of Object.entries(workflow)) {
            const wrapper = rpc_1.HandlerWrapper.fromHandler(handler);
            if (!wrapper) {
                throw new TypeError(`${route} is not a restate handler.`);
            }
            wrapper.bindInstance(workflow);
            component.add(route, wrapper);
        }
        this.addComponent(component);
    }
}
exports.EndpointImpl = EndpointImpl;
//# sourceMappingURL=endpoint_impl.js.map