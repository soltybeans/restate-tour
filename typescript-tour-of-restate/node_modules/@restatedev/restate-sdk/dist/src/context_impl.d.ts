/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { CombineablePromise, ContextDate, DurablePromise, ObjectContext, Rand, Request, RunAction, SendOptions, WorkflowContext } from "./context";
import { StateMachine } from "./state_machine";
import { AsyncLocalStorage } from "node:async_hooks";
import { Client, HandlerKind, SendClient } from "./types/rpc";
import type { Service, ServiceDefinitionFrom, VirtualObjectDefinitionFrom, VirtualObject, WorkflowDefinitionFrom, Workflow } from "@restatedev/restate-sdk-core";
import { WrappedPromise } from "./utils/promises";
import { Buffer } from "node:buffer";
export declare enum CallContextType {
    None = 0,
    Run = 1
}
export interface CallContext {
    type: CallContextType;
    delay?: number;
}
export type InternalCombineablePromise<T> = CombineablePromise<T> & {
    journalIndex: number;
};
export declare class ContextImpl implements ObjectContext, WorkflowContext {
    readonly console: Console;
    readonly handlerKind: HandlerKind;
    readonly keyedContextKey: string | undefined;
    readonly stateMachine: StateMachine;
    readonly rand: Rand;
    static callContext: AsyncLocalStorage<CallContext>;
    private executingRun;
    private readonly invocationRequest;
    readonly date: ContextDate;
    constructor(id: Buffer, console: Console, handlerKind: HandlerKind, keyedContextKey: string | undefined, invocationValue: Uint8Array, invocationHeaders: ReadonlyMap<string, string>, attemptHeaders: ReadonlyMap<string, string | string[] | undefined>, stateMachine: StateMachine, rand?: Rand);
    workflowClient<D>(opts: WorkflowDefinitionFrom<D>, key: string): Client<Workflow<D>>;
    promise<T = void>(name: string): DurablePromise<T>;
    get key(): string;
    request(): Request;
    get<T>(name: string): Promise<T | null>;
    stateKeys(): Promise<Array<string>>;
    set<T>(name: string, value: T): void;
    clear(name: string): void;
    clearAll(): void;
    private invoke;
    private invokeOneWay;
    serviceClient<D>({ name }: ServiceDefinitionFrom<D>): Client<Service<D>>;
    objectClient<D>({ name }: VirtualObjectDefinitionFrom<D>, key: string): Client<VirtualObject<D>>;
    serviceSendClient<D>(service: ServiceDefinitionFrom<D>, opts?: SendOptions): SendClient<Service<D>>;
    objectSendClient<D>(obj: VirtualObjectDefinitionFrom<D>, key: string, opts?: SendOptions): SendClient<VirtualObject<D>>;
    workflowSendClient<D>(def: WorkflowDefinitionFrom<D>, key: string, opts?: SendOptions): SendClient<Workflow<D>>;
    run<T>(nameOrAction: string | RunAction<T>, actionSecondParameter?: RunAction<T>): Promise<T>;
    sleep(millis: number): CombineablePromise<void>;
    private sleepInternal;
    awakeable<T>(): {
        id: string;
        promise: CombineablePromise<T>;
    };
    resolveAwakeable<T>(id: string, payload?: T): void;
    rejectAwakeable(id: string, reason: string): void;
    private completeAwakeable;
    static createCombinator<T extends readonly CombineablePromise<unknown>[]>(combinatorConstructor: (promises: PromiseLike<unknown>[]) => Promise<unknown>, promises: T): WrappedPromise<unknown>;
    private isInRun;
    private checkNotExecutingRun;
    private checkState;
    markCombineablePromise<T>(p: WrappedPromise<T>): InternalCombineablePromise<T>;
}
//# sourceMappingURL=context_impl.d.ts.map