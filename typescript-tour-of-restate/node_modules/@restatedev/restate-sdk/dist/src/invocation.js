"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Invocation = exports.InvocationBuilder = void 0;
const utils_1 = require("./utils/utils");
const protocol_1 = require("./types/protocol");
const local_state_store_1 = require("./local_state_store");
const errors_1 = require("./types/errors");
const logger_1 = require("./logger");
const promises_1 = require("./utils/promises");
const node_buffer_1 = require("node:buffer");
var State;
(function (State) {
    State[State["ExpectingStart"] = 0] = "ExpectingStart";
    State[State["ExpectingInput"] = 1] = "ExpectingInput";
    State[State["ExpectingFurtherReplay"] = 2] = "ExpectingFurtherReplay";
    State[State["Complete"] = 3] = "Complete";
})(State || (State = {}));
class InvocationBuilder {
    component;
    complete = new promises_1.CompletablePromise();
    state = State.ExpectingStart;
    runtimeReplayIndex = 0;
    replayEntries = new Map();
    id = undefined;
    debugId = undefined;
    invocationValue = undefined;
    nbEntriesToReplay = undefined;
    localStateStore;
    userKey;
    invocationHeaders;
    constructor(component) {
        this.component = component;
    }
    handleMessage(m) {
        try {
            switch (this.state) {
                case State.ExpectingStart:
                    checkState(State.ExpectingStart, protocol_1.START_MESSAGE_TYPE, m);
                    this.handleStartMessage(m.message);
                    this.state = State.ExpectingInput;
                    return false;
                case State.ExpectingInput:
                    checkState(State.ExpectingInput, protocol_1.INPUT_ENTRY_MESSAGE_TYPE, m);
                    this.handlePollInputStreamEntry(m);
                    this.addReplayEntry(m);
                    break;
                case State.ExpectingFurtherReplay:
                    this.addReplayEntry(m);
                    break;
                case State.Complete:
                    throw new Error(`Journal builder is getting a message after the journal was complete. entries-to-replay: ${this.nbEntriesToReplay}, message: ${(0, utils_1.formatMessageAsJson)(m)}`);
            }
            this.state =
                this.replayEntries.size === this.nbEntriesToReplay
                    ? State.Complete
                    : State.ExpectingFurtherReplay;
            if (this.state === State.Complete) {
                this.complete.resolve();
                return true;
            }
            return false;
        }
        catch (e) {
            const error = (0, errors_1.ensureError)(e);
            this.complete.reject(error);
            return true; // we want no further messages
        }
    }
    handlePollInputStreamEntry(m) {
        const pollInputStreamMessage = m.message;
        this.invocationValue = node_buffer_1.Buffer.from(pollInputStreamMessage.value);
        if (pollInputStreamMessage.headers) {
            const headers = pollInputStreamMessage.headers.map((header) => [
                header.key,
                header.value,
            ]);
            this.invocationHeaders = new Map(headers);
        }
    }
    handleStreamError(e) {
        this.complete.reject(e);
    }
    handleInputClosed() {
        this.complete.reject(new Error("Input closed before journal is complete"));
    }
    completion() {
        return this.complete.promise;
    }
    handleStartMessage(m) {
        this.nbEntriesToReplay = m.knownEntries;
        this.id = node_buffer_1.Buffer.from(m.id);
        this.debugId = m.debugId;
        this.localStateStore = new local_state_store_1.LocalStateStore(m.partialState, m.stateMap);
        this.userKey = m.key;
        return this;
    }
    addReplayEntry(m) {
        // Will be retrieved when the user code reaches this point
        this.replayEntries.set(this.runtimeReplayIndex, m);
        this.incrementRuntimeReplayIndex();
        return this;
    }
    incrementRuntimeReplayIndex() {
        this.runtimeReplayIndex++;
    }
    isComplete() {
        return this.state === State.Complete;
    }
    build() {
        if (!this.isComplete()) {
            throw new Error(`Cannot build invocation. Not all data present: ${JSON.stringify(this)}`);
        }
        return new Invocation(this.component, this.id, this.debugId, this.nbEntriesToReplay, this.replayEntries, this.invocationValue, this.invocationHeaders ?? new Map(), this.localStateStore, this.userKey);
    }
}
exports.InvocationBuilder = InvocationBuilder;
class Invocation {
    handler;
    id;
    debugId;
    nbEntriesToReplay;
    replayEntries;
    invocationValue;
    invocationHeaders;
    localStateStore;
    userKey;
    constructor(handler, id, debugId, nbEntriesToReplay, replayEntries, invocationValue, invocationHeaders, localStateStore, userKey) {
        this.handler = handler;
        this.id = id;
        this.debugId = debugId;
        this.nbEntriesToReplay = nbEntriesToReplay;
        this.replayEntries = replayEntries;
        this.invocationValue = invocationValue;
        this.invocationHeaders = invocationHeaders;
        this.localStateStore = localStateStore;
        this.userKey = userKey;
    }
    inferLoggerContext(additionalContext) {
        return new logger_1.LoggerContext(this.debugId, "", this.handler.component().name(), this.handler.name(), additionalContext);
    }
}
exports.Invocation = Invocation;
function checkState(state, expected, m) {
    if (m.messageType !== expected) {
        throw new Error(`Unexpected message in state ${state}: ${(0, utils_1.formatMessageAsJson)(m)}`);
    }
}
//# sourceMappingURL=invocation.js.map