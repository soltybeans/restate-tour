import { ErrorMessage, Failure } from "../generated/proto/protocol_pb";
import * as p from "./protocol";
export declare const INTERNAL_ERROR_CODE = 500;
export declare const TIMEOUT_ERROR_CODE = 408;
export declare const UNKNOWN_ERROR_CODE = 500;
export declare enum RestateErrorCodes {
    JOURNAL_MISMATCH = 570,
    PROTOCOL_VIOLATION = 571
}
export type JournalErrorContext = {
    relatedEntryName?: string;
    relatedEntryIndex?: number;
    relatedEntryType?: bigint;
};
export declare function ensureError(e: unknown): Error;
export declare class RestateError extends Error {
    readonly code: number;
    constructor(message: string, options?: {
        errorCode?: number;
        cause?: any;
    });
    toFailure(): Failure;
}
export declare class TerminalError extends RestateError {
    constructor(message: string, options?: {
        errorCode?: number;
        cause?: any;
    });
}
export declare class TimeoutError extends TerminalError {
    constructor();
}
export declare class RetryableError extends RestateError {
    constructor(message: string, options?: {
        errorCode?: number;
        cause?: any;
    });
    static internal(message: string): RetryableError;
    static journalMismatch(journalIndex: number, actualEntry: {
        messageType: bigint;
        message: p.ProtocolMessage | Uint8Array;
    }, expectedEntry: {
        messageType: bigint;
        message: p.ProtocolMessage | Uint8Array;
    }): RetryableError;
    static protocolViolation(message: string): RetryableError;
    static apiViolation(message: string): RetryableError;
}
export declare function errorToFailure(err: Error): Failure;
export declare function failureToTerminalError(failure: Failure): TerminalError;
export declare function failureToError(failure: Failure, terminalError: boolean): Error;
export declare function errorToErrorMessage(err: Error, additionalContext?: JournalErrorContext): ErrorMessage;
//# sourceMappingURL=errors.d.ts.map