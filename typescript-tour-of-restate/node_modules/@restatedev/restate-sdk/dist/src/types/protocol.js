"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isServiceProtocolVersionSupported = exports.SUSPENSION_TRIGGERS = exports.PROTOBUF_MESSAGE_BY_TYPE = exports.formatMessageType = exports.KNOWN_MESSAGE_TYPES = exports.COMPLETE_PROMISE_MESSAGE_TYPE = exports.PEEK_PROMISE_MESSAGE_TYPE = exports.GET_PROMISE_MESSAGE_TYPE = exports.COMBINATOR_ENTRY_MESSAGE = exports.SIDE_EFFECT_ENTRY_MESSAGE_TYPE = exports.AWAKEABLE_IDENTIFIER_PREFIX = exports.COMPLETE_AWAKEABLE_ENTRY_MESSAGE_TYPE = exports.AWAKEABLE_ENTRY_MESSAGE_TYPE = exports.BACKGROUND_INVOKE_ENTRY_MESSAGE_TYPE = exports.INVOKE_ENTRY_MESSAGE_TYPE = exports.SLEEP_ENTRY_MESSAGE_TYPE = exports.GET_STATE_KEYS_ENTRY_MESSAGE_TYPE = exports.CLEAR_ALL_STATE_ENTRY_MESSAGE_TYPE = exports.CLEAR_STATE_ENTRY_MESSAGE_TYPE = exports.SET_STATE_ENTRY_MESSAGE_TYPE = exports.GET_STATE_ENTRY_MESSAGE_TYPE = exports.OUTPUT_ENTRY_MESSAGE_TYPE = exports.INPUT_ENTRY_MESSAGE_TYPE = exports.END_MESSAGE_TYPE = exports.ENTRY_ACK_MESSAGE_TYPE = exports.ERROR_MESSAGE_TYPE = exports.SUSPENSION_MESSAGE_TYPE = exports.COMPLETION_MESSAGE_TYPE = exports.START_MESSAGE_TYPE = exports.CompletePromiseEntryMessage = exports.PeekPromiseEntryMessage = exports.GetPromiseEntryMessage = exports.EntryAckMessage = exports.SuspensionMessage = exports.StartMessage = exports.SleepEntryMessage = exports.SetStateEntryMessage = exports.InputEntryMessage = exports.OutputEntryMessage = exports.CallEntryMessage = exports.GetStateKeysEntryMessage = exports.GetStateEntryMessage = exports.EndMessage = exports.ErrorMessage = exports.CompletionMessage = exports.CompleteAwakeableEntryMessage = exports.ClearAllStateEntryMessage = exports.ClearStateEntryMessage = exports.OneWayCallEntryMessage = exports.AwakeableEntryMessage = void 0;
exports.selectSupportedServiceDiscoveryProtocolVersion = exports.serviceDiscoveryProtocolVersionToHeaderValue = exports.serviceProtocolVersionToHeaderValue = exports.parseServiceProtocolVersion = void 0;
const javascript_pb_1 = require("../generated/proto/javascript_pb");
const protocol_pb_1 = require("../generated/proto/protocol_pb");
const discovery_pb_1 = require("../generated/proto/discovery_pb");
// Re-export the protobuf messages.
var protocol_pb_2 = require("../generated/proto/protocol_pb");
Object.defineProperty(exports, "AwakeableEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.AwakeableEntryMessage; } });
Object.defineProperty(exports, "OneWayCallEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.OneWayCallEntryMessage; } });
Object.defineProperty(exports, "ClearStateEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.ClearStateEntryMessage; } });
Object.defineProperty(exports, "ClearAllStateEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.ClearAllStateEntryMessage; } });
Object.defineProperty(exports, "CompleteAwakeableEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.CompleteAwakeableEntryMessage; } });
Object.defineProperty(exports, "CompletionMessage", { enumerable: true, get: function () { return protocol_pb_2.CompletionMessage; } });
Object.defineProperty(exports, "ErrorMessage", { enumerable: true, get: function () { return protocol_pb_2.ErrorMessage; } });
Object.defineProperty(exports, "EndMessage", { enumerable: true, get: function () { return protocol_pb_2.EndMessage; } });
Object.defineProperty(exports, "GetStateEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.GetStateEntryMessage; } });
Object.defineProperty(exports, "GetStateKeysEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.GetStateKeysEntryMessage; } });
Object.defineProperty(exports, "CallEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.CallEntryMessage; } });
Object.defineProperty(exports, "OutputEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.OutputEntryMessage; } });
Object.defineProperty(exports, "InputEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.InputEntryMessage; } });
Object.defineProperty(exports, "SetStateEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.SetStateEntryMessage; } });
Object.defineProperty(exports, "SleepEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.SleepEntryMessage; } });
Object.defineProperty(exports, "StartMessage", { enumerable: true, get: function () { return protocol_pb_2.StartMessage; } });
Object.defineProperty(exports, "SuspensionMessage", { enumerable: true, get: function () { return protocol_pb_2.SuspensionMessage; } });
Object.defineProperty(exports, "EntryAckMessage", { enumerable: true, get: function () { return protocol_pb_2.EntryAckMessage; } });
Object.defineProperty(exports, "GetPromiseEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.GetPromiseEntryMessage; } });
Object.defineProperty(exports, "PeekPromiseEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.PeekPromiseEntryMessage; } });
Object.defineProperty(exports, "CompletePromiseEntryMessage", { enumerable: true, get: function () { return protocol_pb_2.CompletePromiseEntryMessage; } });
// Export the protocol message types as defined by the restate protocol.
exports.START_MESSAGE_TYPE = 0x0000n;
exports.COMPLETION_MESSAGE_TYPE = 0x0001n;
exports.SUSPENSION_MESSAGE_TYPE = 0x0002n;
exports.ERROR_MESSAGE_TYPE = 0x0003n;
exports.ENTRY_ACK_MESSAGE_TYPE = 0x0004n;
exports.END_MESSAGE_TYPE = 0x0005n;
exports.INPUT_ENTRY_MESSAGE_TYPE = 0x0400n;
exports.OUTPUT_ENTRY_MESSAGE_TYPE = 0x0401n;
exports.GET_STATE_ENTRY_MESSAGE_TYPE = 0x0800n;
exports.SET_STATE_ENTRY_MESSAGE_TYPE = 0x0801n;
exports.CLEAR_STATE_ENTRY_MESSAGE_TYPE = 0x0802n;
exports.CLEAR_ALL_STATE_ENTRY_MESSAGE_TYPE = 0x0803n;
exports.GET_STATE_KEYS_ENTRY_MESSAGE_TYPE = 0x0804n;
exports.SLEEP_ENTRY_MESSAGE_TYPE = 0x0c00n;
exports.INVOKE_ENTRY_MESSAGE_TYPE = 0x0c01n;
exports.BACKGROUND_INVOKE_ENTRY_MESSAGE_TYPE = 0x0c02n;
exports.AWAKEABLE_ENTRY_MESSAGE_TYPE = 0x0c03n;
exports.COMPLETE_AWAKEABLE_ENTRY_MESSAGE_TYPE = 0x0c04n;
exports.AWAKEABLE_IDENTIFIER_PREFIX = "prom_1";
exports.SIDE_EFFECT_ENTRY_MESSAGE_TYPE = 0x0c00n + 5n;
// Export the custom message types
// Side effects are custom messages because the runtime does not need to inspect them
exports.COMBINATOR_ENTRY_MESSAGE = 0xfc02n;
// Durable promise
exports.GET_PROMISE_MESSAGE_TYPE = 0x808n;
exports.PEEK_PROMISE_MESSAGE_TYPE = 0x809n;
exports.COMPLETE_PROMISE_MESSAGE_TYPE = 0x80an;
// Message types in the protocol.
// Custom message types (per SDK) such as side effect entry message should not be included here.
exports.KNOWN_MESSAGE_TYPES = new Set([
    exports.START_MESSAGE_TYPE,
    exports.COMPLETION_MESSAGE_TYPE,
    exports.SUSPENSION_MESSAGE_TYPE,
    exports.ERROR_MESSAGE_TYPE,
    exports.ENTRY_ACK_MESSAGE_TYPE,
    exports.END_MESSAGE_TYPE,
    exports.INPUT_ENTRY_MESSAGE_TYPE,
    exports.OUTPUT_ENTRY_MESSAGE_TYPE,
    exports.GET_STATE_ENTRY_MESSAGE_TYPE,
    exports.GET_STATE_KEYS_ENTRY_MESSAGE_TYPE,
    exports.SET_STATE_ENTRY_MESSAGE_TYPE,
    exports.CLEAR_STATE_ENTRY_MESSAGE_TYPE,
    exports.CLEAR_ALL_STATE_ENTRY_MESSAGE_TYPE,
    exports.SLEEP_ENTRY_MESSAGE_TYPE,
    exports.INVOKE_ENTRY_MESSAGE_TYPE,
    exports.BACKGROUND_INVOKE_ENTRY_MESSAGE_TYPE,
    exports.AWAKEABLE_ENTRY_MESSAGE_TYPE,
    exports.COMPLETE_AWAKEABLE_ENTRY_MESSAGE_TYPE,
    exports.SIDE_EFFECT_ENTRY_MESSAGE_TYPE,
    exports.COMBINATOR_ENTRY_MESSAGE,
    exports.GET_PROMISE_MESSAGE_TYPE,
    exports.PEEK_PROMISE_MESSAGE_TYPE,
    exports.COMPLETE_PROMISE_MESSAGE_TYPE,
]);
const PROTOBUF_MESSAGE_NAME_BY_TYPE = new Map([
    [exports.START_MESSAGE_TYPE, "StartMessage"],
    [exports.COMPLETION_MESSAGE_TYPE, "CompletionMessage"],
    [exports.SUSPENSION_MESSAGE_TYPE, "SuspensionMessage"],
    [exports.ERROR_MESSAGE_TYPE, "ErrorMessage"],
    [exports.ENTRY_ACK_MESSAGE_TYPE, "EntryAckMessage"],
    [exports.END_MESSAGE_TYPE, "EndMessage"],
    [exports.INPUT_ENTRY_MESSAGE_TYPE, "InputEntryMessage"],
    [exports.OUTPUT_ENTRY_MESSAGE_TYPE, "OutputEntryMessage"],
    [exports.GET_STATE_ENTRY_MESSAGE_TYPE, "GetStateEntryMessage"],
    [exports.GET_STATE_KEYS_ENTRY_MESSAGE_TYPE, "GetStateKeysEntryMessage"],
    [exports.SET_STATE_ENTRY_MESSAGE_TYPE, "SetStateEntryMessage"],
    [exports.CLEAR_STATE_ENTRY_MESSAGE_TYPE, "ClearStateEntryMessage"],
    [exports.CLEAR_ALL_STATE_ENTRY_MESSAGE_TYPE, "ClearAllStateEntryMessage"],
    [exports.SLEEP_ENTRY_MESSAGE_TYPE, "SleepEntryMessage"],
    [exports.INVOKE_ENTRY_MESSAGE_TYPE, "CallEntryMessage"],
    [exports.BACKGROUND_INVOKE_ENTRY_MESSAGE_TYPE, "OneWayCallEntryMessage"],
    [exports.AWAKEABLE_ENTRY_MESSAGE_TYPE, "AwakeableEntryMessage"],
    [exports.COMPLETE_AWAKEABLE_ENTRY_MESSAGE_TYPE, "CompleteAwakeableEntryMessage"],
    [exports.SIDE_EFFECT_ENTRY_MESSAGE_TYPE, "RunEntryMessage"],
    [exports.COMBINATOR_ENTRY_MESSAGE, "CombinatorEntryMessage"],
    [exports.GET_PROMISE_MESSAGE_TYPE, "GetPromiseEntryMessage"],
    [exports.PEEK_PROMISE_MESSAGE_TYPE, "PeekPromiseEntryMessage"],
    [exports.COMPLETE_PROMISE_MESSAGE_TYPE, "CompletePromiseEntryMessage"],
]);
const formatMessageType = (messageType) => {
    return (PROTOBUF_MESSAGE_NAME_BY_TYPE.get(messageType) ?? messageType.toString());
};
exports.formatMessageType = formatMessageType;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const PROTOBUF_MESSAGES = [
    [exports.START_MESSAGE_TYPE, protocol_pb_1.StartMessage],
    [exports.COMPLETION_MESSAGE_TYPE, protocol_pb_1.CompletionMessage],
    [exports.SUSPENSION_MESSAGE_TYPE, protocol_pb_1.SuspensionMessage],
    [exports.ERROR_MESSAGE_TYPE, protocol_pb_1.ErrorMessage],
    [exports.ENTRY_ACK_MESSAGE_TYPE, protocol_pb_1.EntryAckMessage],
    [exports.END_MESSAGE_TYPE, protocol_pb_1.EndMessage],
    [exports.INPUT_ENTRY_MESSAGE_TYPE, protocol_pb_1.InputEntryMessage],
    [exports.OUTPUT_ENTRY_MESSAGE_TYPE, protocol_pb_1.OutputEntryMessage],
    [exports.GET_STATE_ENTRY_MESSAGE_TYPE, protocol_pb_1.GetStateEntryMessage],
    [exports.GET_STATE_KEYS_ENTRY_MESSAGE_TYPE, protocol_pb_1.GetStateKeysEntryMessage],
    [exports.SET_STATE_ENTRY_MESSAGE_TYPE, protocol_pb_1.SetStateEntryMessage],
    [exports.CLEAR_STATE_ENTRY_MESSAGE_TYPE, protocol_pb_1.ClearStateEntryMessage],
    [exports.CLEAR_ALL_STATE_ENTRY_MESSAGE_TYPE, protocol_pb_1.ClearAllStateEntryMessage],
    [exports.SLEEP_ENTRY_MESSAGE_TYPE, protocol_pb_1.SleepEntryMessage],
    [exports.INVOKE_ENTRY_MESSAGE_TYPE, protocol_pb_1.CallEntryMessage],
    [exports.BACKGROUND_INVOKE_ENTRY_MESSAGE_TYPE, protocol_pb_1.OneWayCallEntryMessage],
    [exports.AWAKEABLE_ENTRY_MESSAGE_TYPE, protocol_pb_1.AwakeableEntryMessage],
    [exports.COMPLETE_AWAKEABLE_ENTRY_MESSAGE_TYPE, protocol_pb_1.CompleteAwakeableEntryMessage],
    [exports.SIDE_EFFECT_ENTRY_MESSAGE_TYPE, protocol_pb_1.RunEntryMessage],
    [exports.COMBINATOR_ENTRY_MESSAGE, javascript_pb_1.CombinatorEntryMessage],
    [exports.GET_PROMISE_MESSAGE_TYPE, protocol_pb_1.GetPromiseEntryMessage],
    [exports.PEEK_PROMISE_MESSAGE_TYPE, protocol_pb_1.PeekPromiseEntryMessage],
    [exports.COMPLETE_PROMISE_MESSAGE_TYPE, protocol_pb_1.CompletePromiseEntryMessage],
];
exports.PROTOBUF_MESSAGE_BY_TYPE = new Map(PROTOBUF_MESSAGES);
// These message types will trigger sending a suspension message from the runtime
// for each of the protocol modes
exports.SUSPENSION_TRIGGERS = [
    exports.INVOKE_ENTRY_MESSAGE_TYPE,
    exports.GET_STATE_ENTRY_MESSAGE_TYPE,
    exports.GET_STATE_KEYS_ENTRY_MESSAGE_TYPE,
    exports.AWAKEABLE_ENTRY_MESSAGE_TYPE,
    exports.SLEEP_ENTRY_MESSAGE_TYPE,
    exports.COMBINATOR_ENTRY_MESSAGE,
    // We need it because of the ack
    exports.SIDE_EFFECT_ENTRY_MESSAGE_TYPE,
    // promises need completion
    exports.GET_PROMISE_MESSAGE_TYPE,
    exports.PEEK_PROMISE_MESSAGE_TYPE,
    exports.COMPLETE_PROMISE_MESSAGE_TYPE,
];
const MIN_SERVICE_PROTOCOL_VERSION = protocol_pb_1.ServiceProtocolVersion.V1;
const MAX_SERVICE_PROTOCOL_VERSION = protocol_pb_1.ServiceProtocolVersion.V1;
const MIN_SERVICE_DISCOVERY_PROTOCOL_VERSION = discovery_pb_1.ServiceDiscoveryProtocolVersion.V1;
const MAX_SERVICE_DISCOVERY_PROTOCOL_VERSION = discovery_pb_1.ServiceDiscoveryProtocolVersion.V1;
function isServiceProtocolVersionSupported(version) {
    return (version >= MIN_SERVICE_PROTOCOL_VERSION &&
        version <= MAX_SERVICE_PROTOCOL_VERSION);
}
exports.isServiceProtocolVersionSupported = isServiceProtocolVersionSupported;
function isServiceDiscoveryProtocolVersionSupported(version) {
    return (version >= MIN_SERVICE_DISCOVERY_PROTOCOL_VERSION &&
        version <= MAX_SERVICE_DISCOVERY_PROTOCOL_VERSION);
}
function parseServiceProtocolVersion(versionString) {
    // if nothing is set, assume we are using V1
    if (versionString === undefined ||
        versionString === null ||
        versionString === "") {
        return protocol_pb_1.ServiceProtocolVersion.V1;
    }
    versionString = versionString.trim();
    if (versionString === "application/vnd.restate.invocation.v1") {
        return protocol_pb_1.ServiceProtocolVersion.V1;
    }
    return protocol_pb_1.ServiceProtocolVersion.SERVICE_PROTOCOL_VERSION_UNSPECIFIED;
}
exports.parseServiceProtocolVersion = parseServiceProtocolVersion;
function serviceProtocolVersionToHeaderValue(serviceProtocolVersion) {
    switch (serviceProtocolVersion) {
        case protocol_pb_1.ServiceProtocolVersion.V1:
            return "application/vnd.restate.invocation.v1";
        default:
            throw new Error(`Unsupported service discovery protocol version: ${serviceProtocolVersion}`);
    }
}
exports.serviceProtocolVersionToHeaderValue = serviceProtocolVersionToHeaderValue;
function parseServiceDiscoveryProtocolVersion(versionString) {
    versionString = versionString.trim();
    if (versionString === "application/vnd.restate.endpointmanifest.v1+json") {
        return discovery_pb_1.ServiceDiscoveryProtocolVersion.V1;
    }
    return discovery_pb_1.ServiceDiscoveryProtocolVersion.SERVICE_DISCOVERY_PROTOCOL_VERSION_UNSPECIFIED;
}
function serviceDiscoveryProtocolVersionToHeaderValue(serviceDiscoveryProtocolVersion) {
    switch (serviceDiscoveryProtocolVersion) {
        case discovery_pb_1.ServiceDiscoveryProtocolVersion.V1:
            return "application/vnd.restate.endpointmanifest.v1+json";
        default:
            throw new Error(`Unsupported service discovery protocol version: ${serviceDiscoveryProtocolVersion}`);
    }
}
exports.serviceDiscoveryProtocolVersionToHeaderValue = serviceDiscoveryProtocolVersionToHeaderValue;
function selectSupportedServiceDiscoveryProtocolVersion(acceptVersionsString) {
    if (acceptVersionsString === undefined ||
        acceptVersionsString === null ||
        acceptVersionsString === "") {
        return discovery_pb_1.ServiceDiscoveryProtocolVersion.V1;
    }
    let maxVersion = discovery_pb_1.ServiceDiscoveryProtocolVersion.SERVICE_DISCOVERY_PROTOCOL_VERSION_UNSPECIFIED;
    acceptVersionsString.split(",").forEach((versionString) => {
        const version = parseServiceDiscoveryProtocolVersion(versionString);
        if (isServiceDiscoveryProtocolVersionSupported(version) &&
            version > maxVersion) {
            maxVersion = version;
        }
    });
    return maxVersion;
}
exports.selectSupportedServiceDiscoveryProtocolVersion = selectSupportedServiceDiscoveryProtocolVersion;
//# sourceMappingURL=protocol.js.map