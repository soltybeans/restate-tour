"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Header = exports.Message = void 0;
const protocol_1 = require("./protocol");
class Message {
    messageType;
    message;
    completed;
    requiresAck;
    constructor(messageType, message, completed, requiresAck) {
        this.messageType = messageType;
        this.message = message;
        this.completed = completed;
        this.requiresAck = requiresAck;
    }
    // For debugging purposes
    toJSON() {
        const pbType = protocol_1.PROTOBUF_MESSAGE_BY_TYPE.get(this.messageType);
        if (pbType === undefined) {
            return this;
        }
        return {
            messageType: (0, protocol_1.formatMessageType)(this.messageType),
            //eslint-disable-next-line @typescript-eslint/no-explicit-any
            message: this.message.toJson(),
        };
    }
}
exports.Message = Message;
class MessageType {
    static assertValid(messageTypeId) {
        if (protocol_1.KNOWN_MESSAGE_TYPES.has(messageTypeId)) {
            return;
        }
        if ((messageTypeId & CUSTOM_MESSAGE_MASK) !== 0n) {
            return;
        }
        throw new Error(`Unknown message type ${messageTypeId}`);
    }
    static hasCompletedFlag(messageType) {
        return (messageType === protocol_1.GET_STATE_ENTRY_MESSAGE_TYPE ||
            messageType === protocol_1.GET_STATE_KEYS_ENTRY_MESSAGE_TYPE ||
            messageType === protocol_1.SLEEP_ENTRY_MESSAGE_TYPE ||
            messageType === protocol_1.AWAKEABLE_ENTRY_MESSAGE_TYPE);
    }
    static hasProtocolVersion(messageType) {
        return messageType == protocol_1.START_MESSAGE_TYPE;
    }
    static hasRequiresAckFlag(messageType) {
        return (messageType !== protocol_1.START_MESSAGE_TYPE &&
            messageType !== protocol_1.ERROR_MESSAGE_TYPE &&
            messageType !== protocol_1.SUSPENSION_MESSAGE_TYPE &&
            messageType !== protocol_1.ENTRY_ACK_MESSAGE_TYPE &&
            messageType !== protocol_1.COMPLETION_MESSAGE_TYPE);
    }
}
const CUSTOM_MESSAGE_MASK = BigInt(0xfc00);
const COMPLETED_MASK = BigInt(0x0001_0000_0000);
const REQUIRES_ACK_MASK = BigInt(0x8000_0000_0000);
// The header is exported but only for tests.
class Header {
    messageType;
    frameLength;
    completedFlag;
    requiresAckFlag;
    partialStateFlag;
    constructor(messageType, frameLength, completedFlag, requiresAckFlag, partialStateFlag) {
        this.messageType = messageType;
        this.frameLength = frameLength;
        this.completedFlag = completedFlag;
        this.requiresAckFlag = requiresAckFlag;
        this.partialStateFlag = partialStateFlag;
    }
    static fromU64be(value) {
        const messageType = (value >> 48n) & 0xffffn;
        MessageType.assertValid(messageType);
        const completedFlag = MessageType.hasCompletedFlag(messageType) &&
            (value & COMPLETED_MASK) !== 0n
            ? true
            : undefined;
        const requiresAckFlag = MessageType.hasRequiresAckFlag(messageType) &&
            (value & REQUIRES_ACK_MASK) !== 0n
            ? true
            : undefined;
        const frameLength = Number(value & 0xffffffffn);
        return new Header(messageType, frameLength, completedFlag, requiresAckFlag);
    }
    toU64be() {
        let res = (this.messageType << 48n) | BigInt(this.frameLength);
        if (this.completedFlag) {
            res = res | COMPLETED_MASK;
        }
        if (this.requiresAckFlag) {
            res = res | REQUIRES_ACK_MASK;
        }
        return res;
    }
}
exports.Header = Header;
//# sourceMappingURL=types.js.map