"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.workflow = exports.object = exports.service = exports.handlers = exports.HandlerWrapper = exports.HandlerKind = void 0;
const serde_1 = require("../utils/serde");
// ----------- handlers ----------------------------------------------
var HandlerKind;
(function (HandlerKind) {
    HandlerKind[HandlerKind["SERVICE"] = 0] = "SERVICE";
    HandlerKind[HandlerKind["EXCLUSIVE"] = 1] = "EXCLUSIVE";
    HandlerKind[HandlerKind["SHARED"] = 2] = "SHARED";
    HandlerKind[HandlerKind["WORKFLOW"] = 3] = "WORKFLOW";
})(HandlerKind = exports.HandlerKind || (exports.HandlerKind = {}));
const JSON_CONTENT_TYPE = "application/json";
const HANDLER_SYMBOL = Symbol("Handler");
class HandlerWrapper {
    kind;
    handler;
    accept;
    contentType;
    deserializer;
    serializer;
    static from(kind, handler, opts) {
        const input = opts?.accept ?? JSON_CONTENT_TYPE;
        const output = opts?.contentType ?? JSON_CONTENT_TYPE;
        const deserializer = opts?.inputDeserializer ??
            (input.toLocaleLowerCase() == JSON_CONTENT_TYPE
                ? serde_1.deserializeJson
                : serde_1.deserializeNoop);
        const serializer = opts?.outputSerializer ??
            (output.toLocaleLowerCase() == JSON_CONTENT_TYPE
                ? serde_1.serializeJson
                : serde_1.serializeNoop);
        // we must create here a copy of the handler
        // to be able to reuse the original handler in other places.
        // like for example the same logic but under different routes.
        const handlerCopy = function (...args) {
            return handler.apply(this, args);
        };
        return new HandlerWrapper(kind, handlerCopy, input, output, deserializer, serializer);
    }
    static fromHandler(handler) {
        return handler[HANDLER_SYMBOL];
    }
    constructor(kind, handler, accept, contentType, deserializer, serializer) {
        this.kind = kind;
        this.handler = handler;
        this.accept = accept;
        this.contentType = contentType;
        this.deserializer = deserializer;
        this.serializer = serializer;
    }
    bindInstance(t) {
        this.handler = this.handler.bind(t);
    }
    async invoke(context, input) {
        const req = this.deserializer(input);
        const res = await this.handler(context, req);
        return this.serializer(res);
    }
    /**
     * Instead of a HandlerWrapper with a handler property,
     * return the original handler with a HandlerWrapper property.
     * This is needed to keep the appearance of regular functions
     * bound to an object, so that for example, `this.foo(ctx, arg)` would
     * work.
     */
    transpose() {
        const handler = this.handler;
        const existing = HandlerWrapper.fromHandler(handler);
        if (existing !== undefined) {
            return handler;
        }
        Object.defineProperty(handler, HANDLER_SYMBOL, { value: this });
        return handler;
    }
}
exports.HandlerWrapper = HandlerWrapper;
// ----------- handler decorators ----------------------------------------------
var handlers;
(function (handlers) {
    /**
     * Create a service handler.
     *
     * @param opts additional configuration
     * @param fn the actual handler code to execute
     */
    function handler(opts, fn) {
        return HandlerWrapper.from(HandlerKind.SERVICE, fn, opts).transpose();
    }
    handlers.handler = handler;
    let workflow;
    (function (workflow_1) {
        function workflow(optsOrFn, fn) {
            if (typeof optsOrFn == "function") {
                return HandlerWrapper.from(HandlerKind.WORKFLOW, optsOrFn).transpose();
            }
            const opts = optsOrFn;
            if (typeof fn !== "function") {
                throw new TypeError("The second argument must be a function");
            }
            return HandlerWrapper.from(HandlerKind.WORKFLOW, fn, opts).transpose();
        }
        workflow_1.workflow = workflow;
        /**
         * Creates a shared handler for a workflow
         *
         * A shared handler allows a read-only concurrent execution
         * for a given key.
         *
         * @param opts additional configurations
         * @param fn the handler to execute
         */
        function shared(optsOrFn, fn) {
            if (typeof optsOrFn == "function") {
                return HandlerWrapper.from(HandlerKind.SHARED, optsOrFn).transpose();
            }
            const opts = optsOrFn;
            if (typeof fn !== "function") {
                throw new TypeError("The second argument must be a function");
            }
            return HandlerWrapper.from(HandlerKind.SHARED, fn, opts).transpose();
        }
        workflow_1.shared = shared;
    })(workflow = handlers.workflow || (handlers.workflow = {}));
    let object;
    (function (object) {
        /**
         * Creates an exclusive handler for a virtual Object.
         *
         *
         * note 1: This applies only to a virtual object.
         * note 2: This is the default for virtual objects, so if no
         *         additional reconfiguration is needed, you can simply
         *         use the handler directly (no need to use exclusive).
         *         This variant here is only for symmetry/convenance.
         *
         * @param opts additional configurations
         * @param fn the handler to execute
         */
        function exclusive(optsOrFn, fn) {
            if (typeof optsOrFn == "function") {
                return HandlerWrapper.from(HandlerKind.EXCLUSIVE, optsOrFn).transpose();
            }
            const opts = optsOrFn;
            if (typeof fn !== "function") {
                throw new TypeError("The second argument must be a function");
            }
            return HandlerWrapper.from(HandlerKind.EXCLUSIVE, fn, opts).transpose();
        }
        object.exclusive = exclusive;
        /**
         * Creates a shared handler for a virtual Object.
         *
         * A shared handler allows a read-only concurrent execution
         * for a given key.
         *
         * note: This applies only to a virtual object.
         *
         * @param opts additional configurations
         * @param fn the handler to execute
         */
        function shared(optsOrFn, fn) {
            if (typeof optsOrFn == "function") {
                return HandlerWrapper.from(HandlerKind.SHARED, optsOrFn).transpose();
            }
            const opts = optsOrFn;
            if (typeof fn !== "function") {
                throw new TypeError("The second argument must be a function");
            }
            return HandlerWrapper.from(HandlerKind.SHARED, fn, opts).transpose();
        }
        object.shared = shared;
    })(object = handlers.object || (handlers.object = {}));
})(handlers = exports.handlers || (exports.handlers = {}));
/**
 * Define a Restate service.
 *
 * @example Here is an example of how to define a service:
 *
 * ```ts
 *  const greeter = service({
 *    name: "greeter",
 *      handlers: {
 *        greet: async (ctx: Context, name: string) => {
 *          return `Hello ${name}`;
 *        }
 *      }
 * });
 * ```
 *
 * To use the service, you can bind it to an endpoint:
 * ```
 * ...
 * endpoint.bind(greeter)
 * ```
 * @example To use a service, you can export its type to be used in a client:
 * ```
 * export type Greeter = typeof greeter;
 * ...
 * ...
 * import type { Greeter } from "./greeter";
 * const client = ctx.serviceClient<Greeter>({ name : "greeter"});
 * client.greet("World").then(console.log);
 * ```
 *
 * @example Alternatively to avoid repeating the service name, you can:
 * ```
 *  import type {Greeter} from "./greeter";
 *  const Greeter: Greeter = { name : "greeter"};
 *
 *  // now you can reference the service like this:
 *  const client = ctx.serviceClient(Greeter);
 * ```
 *
 * @param name the service name
 * @param handlers the handlers for the service
 * @type P the name of the service
 * @type M the handlers for the service
 */
const service = (service) => {
    if (!service.handlers) {
        throw new Error("service must be defined");
    }
    const handlers = Object.entries(service.handlers).map(([name, handler]) => {
        if (handler instanceof HandlerWrapper) {
            return [name, handler.transpose()];
        }
        if (handler instanceof Function) {
            return [
                name,
                HandlerWrapper.from(HandlerKind.SERVICE, handler).transpose(),
            ];
        }
        throw new TypeError(`Unexpected handler type ${name}`);
    });
    return {
        name: service.name,
        service: Object.fromEntries(handlers),
    };
};
exports.service = service;
/**
 * Define a Restate virtual object.
 *
 * @example Here is an example of how to define a virtual object:
 * ```ts
 *        const counter = object({
 *            name: "counter",
 *            handlers: {
 *                  add: async (ctx: ObjectContext, amount: number) => {},
 *                  get: async (ctx: ObjectContext) => {}
 *            }
 *        })
 *  ```
 *
 * @example To use the object, you can bind it to an endpoint:
 * ```ts
 * ...
 * endpoint.bind(counter)
 * ```
 *
 *  @see to interact with the object, you can use the object client:
 * ```ts
 * ...
 * const client = ctx.objectClient<typeof counter>({ name: "counter"});
 * const res = await client.add(1)
 * ```
 *
 * ### Shared handlers
 *
 * Shared handlers are used to allow concurrent read-only access to the object.
 * This is useful when you want to allow multiple clients to read the object's state at the same time.
 * To define a shared handler, you can use the `shared` decorator as shown below:
 *
 * ```ts
 *      const counter = object({
 *          name: "counter",
 *          handlers: {
 *
 *            add: async (ctx: ObjectContext, amount: number) => { .. },
 *
 *            get: handlers.object.shared(async (ctx: ObjectSharedContext) => {
 *                  return ctx.get<number>("count");
 *            })
 *       }
 *     });
 * ```
 *
 * @param name the name of the object
 * @param handlers the handlers for the object
 */
const object = (object) => {
    if (!object.handlers) {
        throw new Error("object options must be defined");
    }
    const handlers = Object.entries(object.handlers).map(([name, handler]) => {
        if (handler instanceof Function) {
            if (HandlerWrapper.fromHandler(handler) !== undefined) {
                return [name, handler];
            }
            return [
                name,
                HandlerWrapper.from(HandlerKind.EXCLUSIVE, handler).transpose(),
            ];
        }
        throw new TypeError(`Unexpected handler type ${name}`);
    });
    return {
        name: object.name,
        object: Object.fromEntries(handlers),
    };
};
exports.object = object;
/**
 * Define a Restate workflow.
 *
 *
 * @example Here is an example of how to define a workflow:
 * ```ts
 *      const mywf = workflow({
 *            name: "mywf",
 *            handlers: {
 *                run: async (ctx: WorkflowContext, argument: any) => {
 *                  return "Hello World";
 *                }
 *            }
 *      });
 * ```
 *
 * ### Note:
 * * That a workflow must contain exactly one handler named 'run', and this handler must accept as a first argument a WorkflowContext.
 * * The workflow handlers other than 'run' must accept as a first argument a WorkflowSharedContext.
 * * The workflow handlers can not be named 'workflowSubmit', 'workflowAttach', 'workflowOutput' - as these are reserved keywords.
 *
 * @example To use the workflow, you can bind it to an endpoint:
 * ```ts
 * endpoint.bind(mywf)
 * ```
 *
 * @example To interact with the workflow, you can use the workflow client:
 * ```ts
 * const client = ctx.workflowClient<typeof mywf>({ name: "mywf"});
 * const res = await client.run("Hello");
 * ```
 *
 * To use the workflow client from any other environment (like a browser), please refer to the documentation.
 * https://docs.restate.dev
 *
 *
 *
 * @param name the workflow name
 * @param handlers the handlers for the workflow.
 */
const workflow = (workflow) => {
    if (!workflow.handlers) {
        throw new Error("workflow must contain handlers");
    }
    //
    // Add the main 'run' handler
    //
    const runHandler = workflow.handlers["run"];
    let runWrapper;
    if (runHandler instanceof HandlerWrapper) {
        runWrapper = runHandler;
    }
    else if (runHandler instanceof Function) {
        runWrapper =
            HandlerWrapper.fromHandler(runHandler) ??
                HandlerWrapper.from(HandlerKind.WORKFLOW, runHandler);
    }
    else {
        throw new TypeError(`Missing main workflow handler, named 'run'`);
    }
    if (runWrapper.kind != HandlerKind.WORKFLOW) {
        throw new TypeError(`Workflow's main handler handler run, must be of type workflow'`);
    }
    const handlers = [["run", runWrapper.transpose()]];
    //
    // Add all the shared handlers now
    //
    for (const [name, handler] of Object.entries(workflow.handlers)) {
        if (name == "run") {
            continue;
        }
        let wrapper;
        if (handler instanceof HandlerWrapper) {
            wrapper = handler;
        }
        else if (handler instanceof Function) {
            wrapper =
                HandlerWrapper.fromHandler(handler) ??
                    HandlerWrapper.from(HandlerKind.SHARED, handler);
        }
        else {
            throw new TypeError(`Unexpected handler type ${name}`);
        }
        if (wrapper.kind == HandlerKind.WORKFLOW) {
            throw new TypeError(`A workflow must contain exactly one handler annotated as workflow, named 'run'. Please use a shared handler for any additional handlers`);
        }
        handlers.push([name, wrapper.transpose()]);
    }
    return {
        name: workflow.name,
        workflow: Object.fromEntries(handlers),
    };
};
exports.workflow = workflow;
//# sourceMappingURL=rpc.js.map