"use strict";
/*
 * Copyright (c) 2023-2024 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextImpl = exports.CallContextType = void 0;
const protocol_pb_1 = require("./generated/proto/protocol_pb");
const protocol_1 = require("./types/protocol");
const node_async_hooks_1 = require("node:async_hooks");
const errors_1 = require("./types/errors");
const utils_1 = require("./utils/utils");
const protobuf_1 = require("@bufbuild/protobuf");
const rpc_1 = require("./types/rpc");
const rand_1 = require("./utils/rand");
const promise_combinator_tracker_1 = require("./promise_combinator_tracker");
const node_buffer_1 = require("node:buffer");
const serde_1 = require("./utils/serde");
var CallContextType;
(function (CallContextType) {
    CallContextType[CallContextType["None"] = 0] = "None";
    CallContextType[CallContextType["Run"] = 1] = "Run";
})(CallContextType = exports.CallContextType || (exports.CallContextType = {}));
class ContextImpl {
    console;
    handlerKind;
    keyedContextKey;
    stateMachine;
    rand;
    // here, we capture the context information for actions on the Restate context that
    // are executed within other actions, such as
    // ctx.oneWayCall( () => client.foo(bar) );
    // we also use this information to ensure we check that only allowed operations are
    // used. Within side-effects, no operations are allowed on the RestateContext.
    // For example, this is illegal: 'ctx.sideEffect(() => {await ctx.get("my-state")})'
    static callContext = new node_async_hooks_1.AsyncLocalStorage();
    // This is used to guard users against calling ctx.sideEffect without awaiting it.
    // See https://github.com/restatedev/sdk-typescript/issues/197 for more details.
    executingRun = false;
    invocationRequest;
    date = {
        now: () => {
            return this.run(() => Date.now());
        },
        toJSON: () => {
            return this.run(() => new Date().toJSON());
        },
    };
    constructor(id, console, handlerKind, keyedContextKey, invocationValue, invocationHeaders, attemptHeaders, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    stateMachine, rand = new rand_1.RandImpl(id)) {
        this.console = console;
        this.handlerKind = handlerKind;
        this.keyedContextKey = keyedContextKey;
        this.stateMachine = stateMachine;
        this.rand = rand;
        this.invocationRequest = {
            id,
            headers: invocationHeaders,
            attemptHeaders,
            body: invocationValue,
        };
    }
    workflowClient(opts, key) {
        const { name } = opts;
        const clientProxy = new Proxy({}, {
            get: (_target, prop) => {
                const route = prop;
                return (...args) => {
                    const requestBytes = (0, serde_1.serializeJson)(args.shift());
                    return this.invoke(name, route, requestBytes, key);
                };
            },
        });
        return clientProxy;
    }
    promise(name) {
        return new DurablePromiseImpl(this, name);
    }
    get key() {
        switch (this.handlerKind) {
            case rpc_1.HandlerKind.EXCLUSIVE:
            case rpc_1.HandlerKind.SHARED:
            case rpc_1.HandlerKind.WORKFLOW: {
                if (this.keyedContextKey === undefined) {
                    throw new errors_1.TerminalError("unexpected missing key");
                }
                return this.keyedContextKey;
            }
            case rpc_1.HandlerKind.SERVICE:
                throw new errors_1.TerminalError("unexpected missing key");
            default:
                throw new errors_1.TerminalError("unknown handler type");
        }
    }
    request() {
        return this.invocationRequest;
    }
    // DON'T make this function async!!! see sideEffect comment for details.
    get(name) {
        // Check if this is a valid action
        this.checkState("get state");
        // Create the message and let the state machine process it
        const msg = new protocol_pb_1.GetStateEntryMessage({ key: node_buffer_1.Buffer.from(name) });
        const completed = this.stateMachine.localStateStore.tryCompleteGet(name, msg);
        const getState = async () => {
            const result = await this.stateMachine.handleUserCodeMessage(protocol_1.GET_STATE_ENTRY_MESSAGE_TYPE, msg, completed);
            // If the GetState message did not have a value or empty,
            // then we went to the runtime to get the value.
            // When we get the response, we set it in the localStateStore,
            // to answer subsequent requests
            if (!completed) {
                this.stateMachine.localStateStore.add(name, result);
            }
            if (!(result instanceof node_buffer_1.Buffer)) {
                return null;
            }
            return (0, utils_1.jsonDeserialize)(result.toString());
        };
        return getState();
    }
    // DON'T make this function async!!! see sideEffect comment for details.
    stateKeys() {
        // Check if this is a valid action
        this.checkState("state keys");
        // Create the message and let the state machine process it
        const msg = new protocol_pb_1.GetStateKeysEntryMessage({});
        const completed = this.stateMachine.localStateStore.tryCompletedGetStateKeys(msg);
        const getStateKeys = async () => {
            const result = await this.stateMachine.handleUserCodeMessage(protocol_1.GET_STATE_KEYS_ENTRY_MESSAGE_TYPE, msg, completed);
            return result.keys.map((b) => b.toString());
        };
        return getStateKeys();
    }
    set(name, value) {
        this.checkState("set state");
        const msg = this.stateMachine.localStateStore.set(name, value);
        this.stateMachine
            .handleUserCodeMessage(protocol_1.SET_STATE_ENTRY_MESSAGE_TYPE, msg)
            .catch((e) => this.stateMachine.handleDanglingPromiseError(e));
    }
    clear(name) {
        this.checkState("clear state");
        const msg = this.stateMachine.localStateStore.clear(name);
        this.stateMachine
            .handleUserCodeMessage(protocol_1.CLEAR_STATE_ENTRY_MESSAGE_TYPE, msg)
            .catch((e) => this.stateMachine.handleDanglingPromiseError(e));
    }
    clearAll() {
        this.checkState("clear all state");
        const msg = this.stateMachine.localStateStore.clearAll();
        this.stateMachine
            .handleUserCodeMessage(protocol_1.CLEAR_ALL_STATE_ENTRY_MESSAGE_TYPE, msg)
            .catch((e) => this.stateMachine.handleDanglingPromiseError(e));
    }
    // --- Calls, background calls, etc
    // DON'T make this function async!!! see sideEffect comment for details.
    invoke(service, method, data, key
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    ) {
        this.checkState("invoke");
        const msg = new protocol_pb_1.CallEntryMessage({
            serviceName: service,
            handlerName: method,
            parameter: data,
            key,
        });
        return this.markCombineablePromise(this.stateMachine
            .handleUserCodeMessage(protocol_1.INVOKE_ENTRY_MESSAGE_TYPE, msg)
            .transform((v) => (0, serde_1.deserializeJson)(v)));
    }
    async invokeOneWay(service, method, data, delay, key) {
        const actualDelay = delay || 0;
        const invokeTime = actualDelay > 0 ? Date.now() + actualDelay : protobuf_1.protoInt64.zero;
        const msg = new protocol_pb_1.OneWayCallEntryMessage({
            serviceName: service,
            handlerName: method,
            parameter: data,
            invokeTime: protobuf_1.protoInt64.parse(invokeTime),
            key,
        });
        await this.stateMachine.handleUserCodeMessage(protocol_1.BACKGROUND_INVOKE_ENTRY_MESSAGE_TYPE, msg);
        return new Uint8Array();
    }
    serviceClient({ name }) {
        const clientProxy = new Proxy({}, {
            get: (_target, prop) => {
                const route = prop;
                return (...args) => {
                    const requestBytes = (0, serde_1.serializeJson)(args.shift());
                    return this.invoke(name, route, requestBytes);
                };
            },
        });
        return clientProxy;
    }
    objectClient({ name }, key) {
        const clientProxy = new Proxy({}, {
            get: (_target, prop) => {
                const route = prop;
                return (...args) => {
                    const requestBytes = (0, serde_1.serializeJson)(args.shift());
                    return this.invoke(name, route, requestBytes, key);
                };
            },
        });
        return clientProxy;
    }
    serviceSendClient(service, opts) {
        const clientProxy = new Proxy({}, {
            get: (_target, prop) => {
                const route = prop;
                return (...args) => {
                    const requestBytes = (0, serde_1.serializeJson)(args.shift());
                    this.invokeOneWay(service.name, route, requestBytes, opts?.delay).catch((e) => {
                        this.stateMachine.handleDanglingPromiseError(e);
                    });
                };
            },
        });
        return clientProxy;
    }
    objectSendClient(obj, key, opts) {
        const clientProxy = new Proxy({}, {
            get: (_target, prop) => {
                const route = prop;
                return (...args) => {
                    const requestBytes = (0, serde_1.serializeJson)(args.shift());
                    this.invokeOneWay(obj.name, route, requestBytes, opts?.delay, key).catch((e) => {
                        this.stateMachine.handleDanglingPromiseError(e);
                    });
                };
            },
        });
        return clientProxy;
    }
    workflowSendClient(def, key, opts) {
        const clientProxy = new Proxy({}, {
            get: (_target, prop) => {
                const route = prop;
                return (...args) => {
                    const requestBytes = (0, serde_1.serializeJson)(args.shift());
                    this.invokeOneWay(def.name, route, requestBytes, opts?.delay, key).catch((e) => {
                        this.stateMachine.handleDanglingPromiseError(e);
                    });
                };
            },
        });
        return clientProxy;
    }
    // DON'T make this function async!!!
    // The reason is that we want the errors thrown by the initial checks to be propagated in the caller context,
    // and not in the promise context. To understand the semantic difference, make this function async and run the
    // UnawaitedSideEffectShouldFailSubsequentContextCall test.
    run(nameOrAction, actionSecondParameter) {
        const { name, action } = unpack(nameOrAction, actionSecondParameter);
        if (this.isInRun()) {
            throw new errors_1.TerminalError("Not possible to nest runs.", {
                errorCode: errors_1.INTERNAL_ERROR_CODE,
            });
        }
        this.checkNotExecutingRun();
        this.executingRun = true;
        const executeRun = async () => {
            // in replay mode, we directly return the value from the log
            if (this.stateMachine.nextEntryWillBeReplayed()) {
                const emptyMsg = new protocol_pb_1.RunEntryMessage({});
                return this.stateMachine.handleUserCodeMessage(protocol_1.SIDE_EFFECT_ENTRY_MESSAGE_TYPE, emptyMsg);
            }
            let sideEffectResult;
            try {
                sideEffectResult = await ContextImpl.callContext.run({ type: CallContextType.Run }, () => action());
            }
            catch (e) {
                if (!(e instanceof errors_1.TerminalError)) {
                    ///non terminal errors are retirable.
                    // we do not commit the error itself into the journal, but rather let restate know about this
                    // so that restate can retry this invocation later.
                    // Before we can propagate this error to the user, we must let the state machine know that this attempt
                    // is finished with an error, and it should not append anything else to the journal from now on.
                    const error = (0, errors_1.ensureError)(e);
                    const additionalContext = {
                        relatedEntryName: name,
                        relatedEntryType: protocol_1.SIDE_EFFECT_ENTRY_MESSAGE_TYPE,
                    };
                    await this.stateMachine.sendErrorAndFinish(error, additionalContext);
                    throw e;
                }
                // we commit a terminal error from the side effect to the journal, and re-throw it into
                // the function. that way, any catching by the user and reacting to it will be
                // deterministic on replay
                const error = (0, errors_1.ensureError)(e);
                const failure = (0, errors_1.errorToFailure)(error);
                const sideEffectMsg = new protocol_pb_1.RunEntryMessage({
                    name,
                    result: { case: "failure", value: failure },
                });
                // this may throw an error from the SDK/runtime/connection side, in case the
                // failure message cannot be committed to the journal. That error would then
                // be returned from this function (replace the original error)
                // that is acceptable, because in such a situation (failure to append to journal),
                // the state machine closes anyways and no further operations will succeed and the
                // the execution aborts
                await this.stateMachine.handleUserCodeMessage(protocol_1.SIDE_EFFECT_ENTRY_MESSAGE_TYPE, sideEffectMsg, false, true);
                throw e;
            }
            // we have this code outside the above try/catch block, to ensure that any error arising
            // from here is not incorrectly attributed to the side-effect
            const sideEffectMsg = sideEffectResult !== undefined
                ? new protocol_pb_1.RunEntryMessage({
                    name,
                    result: {
                        case: "value",
                        value: node_buffer_1.Buffer.from((0, utils_1.jsonSerialize)(sideEffectResult)),
                    },
                })
                : new protocol_pb_1.RunEntryMessage({
                    name,
                });
            // if an error arises from committing the side effect result, then this error will
            // be thrown here (reject the returned promise) and the function will see that error,
            // even if the side-effect function completed correctly
            // that is acceptable, because in such a situation (failure to append to journal),
            // the state machine closes anyways and reports an execution failure, meaning no further
            // operations will succeed and the the execution will be retried.
            // If the side-effect result did in fact not make it to the journal, then the side-effect
            // re-executes, and if it made it to the journal after all (error happend inly during
            // ack-back), then retries will use the journaled result.
            // So all good in any case, due to the beauty of "the runtime log is the ground thruth" approach.
            await this.stateMachine.handleUserCodeMessage(protocol_1.SIDE_EFFECT_ENTRY_MESSAGE_TYPE, sideEffectMsg, false, true);
            return sideEffectResult;
        };
        return executeRun().finally(() => {
            this.executingRun = false;
        });
    }
    sleep(millis) {
        this.checkState("sleep");
        return this.markCombineablePromise(this.sleepInternal(millis));
    }
    sleepInternal(millis) {
        return this.stateMachine.handleUserCodeMessage(protocol_1.SLEEP_ENTRY_MESSAGE_TYPE, new protocol_pb_1.SleepEntryMessage({
            wakeUpTime: protobuf_1.protoInt64.parse(Date.now() + millis),
        }));
    }
    // -- Awakeables
    awakeable() {
        this.checkState("awakeable");
        const msg = new protocol_pb_1.AwakeableEntryMessage();
        const promise = this.stateMachine
            .handleUserCodeMessage(protocol_1.AWAKEABLE_ENTRY_MESSAGE_TYPE, msg)
            .transform((result) => {
            if (!(result instanceof node_buffer_1.Buffer)) {
                // This should either be a filled buffer or an empty buffer but never anything else.
                throw errors_1.RetryableError.internal("Awakeable was not resolved with a buffer payload");
            }
            return JSON.parse(result.toString());
        });
        // This needs to be done after handling the message in the state machine
        // otherwise the index is not yet incremented.
        const encodedEntryIndex = node_buffer_1.Buffer.alloc(4 /* Size of u32 */);
        encodedEntryIndex.writeUInt32BE(this.stateMachine.getUserCodeJournalIndex());
        return {
            id: protocol_1.AWAKEABLE_IDENTIFIER_PREFIX +
                node_buffer_1.Buffer.concat([this.request().id, encodedEntryIndex]).toString("base64url"),
            promise: this.markCombineablePromise(promise),
        };
    }
    resolveAwakeable(id, payload) {
        // We coerce undefined to null as null can be stringified by JSON.stringify
        const payloadToWrite = payload === undefined ? null : payload;
        this.checkState("resolveAwakeable");
        this.completeAwakeable(id, {
            result: {
                case: "value",
                value: node_buffer_1.Buffer.from(JSON.stringify(payloadToWrite)),
            },
        });
    }
    rejectAwakeable(id, reason) {
        this.checkState("rejectAwakeable");
        this.completeAwakeable(id, {
            result: {
                case: "failure",
                value: { code: errors_1.UNKNOWN_ERROR_CODE, message: reason },
            },
        });
    }
    completeAwakeable(id, base) {
        base.id = id;
        this.stateMachine
            .handleUserCodeMessage(protocol_1.COMPLETE_AWAKEABLE_ENTRY_MESSAGE_TYPE, new protocol_pb_1.CompleteAwakeableEntryMessage(base))
            .catch((e) => this.stateMachine.handleDanglingPromiseError(e));
    }
    // Used by static methods of CombineablePromise
    static createCombinator(combinatorConstructor, promises) {
        const self = extractContext(promises[0]);
        if (!self) {
            throw errors_1.RetryableError.internal("Not a combinable promise");
        }
        const outPromises = [];
        for (const promise of promises) {
            if (extractContext(promise) !== self) {
                throw errors_1.RetryableError.internal("You're mixing up CombineablePromises from different RestateContext. This is not supported.");
            }
            const index = promise
                .journalIndex;
            outPromises.push({
                id: (0, promise_combinator_tracker_1.newJournalEntryPromiseId)(index),
                promise: promise,
            });
        }
        return self.stateMachine.createCombinator(combinatorConstructor, outPromises);
    }
    // -- Various private methods
    isInRun() {
        const context = ContextImpl.callContext.getStore();
        return context?.type === CallContextType.Run;
    }
    checkNotExecutingRun() {
        if (this.executingRun) {
            throw new errors_1.TerminalError(`Invoked a RestateContext method while a run() is still executing.
          Make sure you await the ctx.run() call before using any other RestateContext method.`, { errorCode: errors_1.INTERNAL_ERROR_CODE });
        }
    }
    checkState(callType) {
        const context = ContextImpl.callContext.getStore();
        if (!context) {
            this.checkNotExecutingRun();
            return;
        }
        if (context.type === CallContextType.Run) {
            throw new errors_1.TerminalError(`You cannot do ${callType} calls from within a run.`, { errorCode: errors_1.INTERNAL_ERROR_CODE });
        }
    }
    markCombineablePromise(p) {
        const journalIndex = this.stateMachine.getUserCodeJournalIndex();
        const orTimeout = (millis) => {
            const sleepPromise = this.sleepInternal(millis).transform(() => {
                throw new errors_1.TimeoutError();
            });
            const sleepPromiseIndex = this.stateMachine.getUserCodeJournalIndex();
            return this.stateMachine.createCombinator(Promise.race.bind(Promise), [
                {
                    id: (0, promise_combinator_tracker_1.newJournalEntryPromiseId)(journalIndex),
                    promise: p,
                },
                {
                    id: (0, promise_combinator_tracker_1.newJournalEntryPromiseId)(sleepPromiseIndex),
                    promise: sleepPromise,
                },
            ]);
        };
        defineProperty(p, RESTATE_CTX_SYMBOL, this);
        defineProperty(p, "journalIndex", journalIndex);
        defineProperty(p, "orTimeout", orTimeout.bind(this));
        return p;
    }
}
exports.ContextImpl = ContextImpl;
// wraps defineProperty such that it informs tsc of the correct type of its output
function defineProperty(obj, prop, value) {
    Object.defineProperty(obj, prop, { value });
}
function unpack(a, b) {
    if (typeof a == "string") {
        if (typeof b !== "function") {
            throw new TypeError("");
        }
        return { name: a, action: b };
    }
    if (typeof a !== "function") {
        throw new TypeError("unexpected type at the first parameter");
    }
    if (b) {
        throw new TypeError("unexpected a function as a second parameter.");
    }
    return { action: a };
}
const RESTATE_CTX_SYMBOL = Symbol("restateContext");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function extractContext(n) {
    return n[RESTATE_CTX_SYMBOL];
}
class DurablePromiseImpl {
    ctx;
    name;
    constructor(ctx, name) {
        this.ctx = ctx;
        this.name = name;
    }
    then(onfulfilled, onrejected) {
        return this.get().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        return this.get().catch(onrejected);
    }
    finally(onfinally) {
        return this.get().finally(onfinally);
    }
    [Symbol.toStringTag] = "DurablePromise";
    get() {
        const msg = new protocol_pb_1.GetPromiseEntryMessage({
            key: this.name,
        });
        return this.ctx.markCombineablePromise(this.ctx.stateMachine
            .handleUserCodeMessage(protocol_1.GET_PROMISE_MESSAGE_TYPE, msg)
            .transform((v) => (0, serde_1.deserializeJson)(v)));
    }
    peek() {
        const msg = new protocol_pb_1.PeekPromiseEntryMessage({
            key: this.name,
        });
        return this.ctx.stateMachine
            .handleUserCodeMessage(protocol_1.PEEK_PROMISE_MESSAGE_TYPE, msg)
            .transform((v) => v instanceof protocol_pb_1.Empty ? undefined : (0, serde_1.deserializeJson)(v));
    }
    resolve(value) {
        const msg = new protocol_pb_1.CompletePromiseEntryMessage({
            key: this.name,
            completion: {
                case: "completionValue",
                value: (0, serde_1.serializeJson)(value),
            },
        });
        return this.ctx.stateMachine.handleUserCodeMessage(protocol_1.COMPLETE_PROMISE_MESSAGE_TYPE, msg);
    }
    reject(errorMsg) {
        const msg = new protocol_pb_1.CompletePromiseEntryMessage({
            key: this.name,
            completion: {
                case: "completionFailure",
                value: {
                    message: errorMsg,
                },
            },
        });
        return this.ctx.stateMachine.handleUserCodeMessage(protocol_1.COMPLETE_PROMISE_MESSAGE_TYPE, msg);
    }
}
//# sourceMappingURL=context_impl.js.map